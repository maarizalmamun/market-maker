"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriftClient = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const bs58_1 = __importDefault(require("bs58"));
const spl_token_1 = require("@solana/spl-token");
const types_1 = require("./types");
const anchor = __importStar(require("@coral-xyz/anchor"));
const drift_json_1 = __importDefault(require("./idl/drift.json"));
const web3_js_1 = require("@solana/web3.js");
const pda_1 = require("./addresses/pda");
const utils_1 = require("./tx/utils");
const numericConstants_1 = require("./constants/numericConstants");
const position_1 = require("./math/position");
const spotBalance_1 = require("./math/spotBalance");
const userName_1 = require("./userName");
const pollingDriftClientAccountSubscriber_1 = require("./accounts/pollingDriftClientAccountSubscriber");
const webSocketDriftClientAccountSubscriber_1 = require("./accounts/webSocketDriftClientAccountSubscriber");
const retryTxSender_1 = require("./tx/retryTxSender");
const user_1 = require("./user");
const config_1 = require("./config");
const spotMarkets_1 = require("./constants/spotMarkets");
const userStats_1 = require("./userStats");
const spotPosition_1 = require("./math/spotPosition");
const market_1 = require("./math/market");
/**
 * # DriftClient
 * This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more.
 */
class DriftClient {
    get isSubscribed() {
        return this._isSubscribed && this.accountSubscriber.isSubscribed;
    }
    set isSubscribed(val) {
        this._isSubscribed = val;
    }
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.users = new Map();
        this._isSubscribed = false;
        this.perpMarketLastSlotCache = new Map();
        this.spotMarketLastSlotCache = new Map();
        this.connection = config.connection;
        this.wallet = config.wallet;
        this.opts = config.opts || anchor_1.AnchorProvider.defaultOptions();
        this.provider = new anchor_1.AnchorProvider(config.connection, config.wallet, this.opts);
        this.program = new anchor_1.Program(drift_json_1.default, config.programID, this.provider);
        this.authority = (_a = config.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        this.activeSubAccountId = (_b = config.activeSubAccountId) !== null && _b !== void 0 ? _b : 0;
        this.skipLoadUsers = (_c = config.skipLoadUsers) !== null && _c !== void 0 ? _c : false;
        if (config.includeDelegates && config.subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (config.authoritySubAccountMap && config.subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (config.authoritySubAccountMap && config.includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = config.authoritySubAccountMap
            ? config.authoritySubAccountMap
            : config.subAccountIds
                ? new Map([[this.authority.toString(), config.subAccountIds]])
                : new Map();
        this.includeDelegates = (_d = config.includeDelegates) !== null && _d !== void 0 ? _d : false;
        this.userAccountSubscriptionConfig =
            ((_e = config.accountSubscription) === null || _e === void 0 ? void 0 : _e.type) === 'polling'
                ? {
                    type: 'polling',
                    accountLoader: config.accountSubscription.accountLoader,
                }
                : {
                    type: 'websocket',
                };
        if (config.userStats) {
            this.userStats = new userStats_1.UserStats({
                driftClient: this,
                userStatsAccountPublicKey: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority),
                accountSubscription: this.userAccountSubscriptionConfig,
            });
        }
        let perpMarketIndexes = config.perpMarketIndexes;
        let spotMarketIndexes = config.spotMarketIndexes;
        let oracleInfos = config.oracleInfos;
        if (config.env) {
            const { perpMarketIndexes: envPerpMarketIndexes, spotMarketIndexes: envSpotMarketIndexes, oracleInfos: envOracleInfos, } = (0, config_1.getMarketsAndOraclesForSubscription)(config.env);
            perpMarketIndexes = perpMarketIndexes
                ? perpMarketIndexes
                : envPerpMarketIndexes;
            spotMarketIndexes = spotMarketIndexes
                ? spotMarketIndexes
                : envSpotMarketIndexes;
            oracleInfos = oracleInfos ? oracleInfos : envOracleInfos;
        }
        this.marketLookupTable = config.marketLookupTable;
        if (config.env && !this.marketLookupTable) {
            this.marketLookupTable = new web3_js_1.PublicKey(config_1.configs[config.env].MARKET_LOOKUP_TABLE);
        }
        if (((_f = config.accountSubscription) === null || _f === void 0 ? void 0 : _f.type) === 'polling') {
            this.accountSubscriber = new pollingDriftClientAccountSubscriber_1.PollingDriftClientAccountSubscriber(this.program, config.accountSubscription.accountLoader, perpMarketIndexes !== null && perpMarketIndexes !== void 0 ? perpMarketIndexes : [], spotMarketIndexes !== null && spotMarketIndexes !== void 0 ? spotMarketIndexes : [], oracleInfos !== null && oracleInfos !== void 0 ? oracleInfos : []);
        }
        else {
            this.accountSubscriber = new webSocketDriftClientAccountSubscriber_1.WebSocketDriftClientAccountSubscriber(this.program, perpMarketIndexes !== null && perpMarketIndexes !== void 0 ? perpMarketIndexes : [], spotMarketIndexes !== null && spotMarketIndexes !== void 0 ? spotMarketIndexes : [], oracleInfos !== null && oracleInfos !== void 0 ? oracleInfos : []);
        }
        this.eventEmitter = this.accountSubscriber.eventEmitter;
        this.txSender = new retryTxSender_1.RetryTxSender(this.provider, (_g = config.txSenderConfig) === null || _g === void 0 ? void 0 : _g.timeout, (_h = config.txSenderConfig) === null || _h === void 0 ? void 0 : _h.retrySleep, (_j = config.txSenderConfig) === null || _j === void 0 ? void 0 : _j.additionalConnections);
    }
    getUserMapKey(subAccountId, authority) {
        return `${subAccountId}_${authority.toString()}`;
    }
    createUser(subAccountId, accountSubscriptionConfig, authority) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.authority, subAccountId);
        return new user_1.User({
            driftClient: this,
            userAccountPublicKey,
            accountSubscription: accountSubscriptionConfig,
        });
    }
    async subscribe() {
        let subscribePromises = [this.addAndSubscribeToUsers()].concat(this.accountSubscriber.subscribe());
        if (this.userStats !== undefined) {
            subscribePromises = subscribePromises.concat(this.userStats.subscribe());
        }
        this.isSubscribed = (await Promise.all(subscribePromises)).reduce((success, prevSuccess) => success && prevSuccess);
        return this.isSubscribed;
    }
    subscribeUsers() {
        return [...this.users.values()].map((user) => user.subscribe());
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    async fetchAccounts() {
        let promises = [...this.users.values()]
            .map((user) => user.fetchAccounts())
            .concat(this.accountSubscriber.fetch());
        if (this.userStats) {
            promises = promises.concat(this.userStats.fetchAccounts());
        }
        await Promise.all(promises);
    }
    async unsubscribe() {
        let unsubscribePromises = this.unsubscribeUsers().concat(this.accountSubscriber.unsubscribe());
        if (this.userStats !== undefined) {
            unsubscribePromises = unsubscribePromises.concat(this.userStats.unsubscribe());
        }
        await Promise.all(unsubscribePromises);
        this.isSubscribed = false;
    }
    unsubscribeUsers() {
        return [...this.users.values()].map((user) => user.unsubscribe());
    }
    async getStatePublicKey() {
        if (this.statePublicKey) {
            return this.statePublicKey;
        }
        this.statePublicKey = await (0, pda_1.getDriftStateAccountPublicKey)(this.program.programId);
        return this.statePublicKey;
    }
    getSignerPublicKey() {
        if (this.signerPublicKey) {
            return this.signerPublicKey;
        }
        this.signerPublicKey = (0, pda_1.getDriftSignerPublicKey)(this.program.programId);
        return this.signerPublicKey;
    }
    getStateAccount() {
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     */
    async forceGetStateAccount() {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    getPerpMarketAccount(marketIndex) {
        var _a;
        return (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetPerpMarketAccount(marketIndex) {
        var _a, _b;
        await this.accountSubscriber.fetch();
        let data = (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
        let i = 0;
        while (data === undefined && i < 10) {
            await this.accountSubscriber.fetch();
            data = (_b = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _b === void 0 ? void 0 : _b.data;
            i++;
        }
        return data;
    }
    getPerpMarketAccounts() {
        return this.accountSubscriber
            .getMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getSpotMarketAccount(marketIndex) {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetSpotMarketAccount(marketIndex) {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    getSpotMarketAccounts() {
        return this.accountSubscriber
            .getSpotMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getQuoteSpotMarketAccount() {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(numericConstants_1.QUOTE_SPOT_MARKET_INDEX).data;
    }
    getOraclePriceDataAndSlot(oraclePublicKey) {
        return this.accountSubscriber.getOraclePriceDataAndSlot(oraclePublicKey);
    }
    async getSerumV3FulfillmentConfig(serumMarket) {
        const address = await (0, pda_1.getSerumFulfillmentConfigPublicKey)(this.program.programId, serumMarket);
        return (await this.program.account.serumV3FulfillmentConfig.fetch(address));
    }
    async getPhoenixV1FulfillmentConfig(phoenixMarket) {
        const address = await (0, pda_1.getPhoenixFulfillmentConfigPublicKey)(this.program.programId, phoenixMarket);
        return (await this.program.account.phoenixV1FulfillmentConfig.fetch(address));
    }
    async fetchMarketLookupTableAccount() {
        if (this.lookupTableAccount)
            return this.lookupTableAccount;
        if (!this.marketLookupTable) {
            console.log('Market lookup table address not set');
            return;
        }
        const lookupTableAccount = (await this.connection.getAddressLookupTable(this.marketLookupTable)).value;
        this.lookupTableAccount = lookupTableAccount;
        return lookupTableAccount;
    }
    /**
     * Update the wallet to use for drift transactions and linked user account
     * @param newWallet
     * @param subAccountIds
     * @param activeSubAccountId
     * @param includeDelegates
     */
    async updateWallet(newWallet, subAccountIds, activeSubAccountId, includeDelegates, authoritySubaccountMap) {
        const newProvider = new anchor_1.AnchorProvider(this.connection, newWallet, this.opts);
        const newProgram = new anchor_1.Program(drift_json_1.default, this.program.programId, newProvider);
        this.skipLoadUsers = false;
        // Update provider for txSender with new wallet details
        this.txSender.provider = newProvider;
        this.wallet = newWallet;
        this.provider = newProvider;
        this.program = newProgram;
        this.authority = newWallet.publicKey;
        this.activeSubAccountId = activeSubAccountId;
        this.userStatsAccountPublicKey = undefined;
        this.includeDelegates = includeDelegates !== null && includeDelegates !== void 0 ? includeDelegates : false;
        if (includeDelegates && subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (authoritySubaccountMap && subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (authoritySubaccountMap && includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = authoritySubaccountMap
            ? authoritySubaccountMap
            : subAccountIds
                ? new Map([[this.authority.toString(), subAccountIds]])
                : new Map();
        let success = true;
        if (this.isSubscribed) {
            await Promise.all(this.unsubscribeUsers());
            if (this.userStats) {
                await this.userStats.unsubscribe();
                this.userStats = new userStats_1.UserStats({
                    driftClient: this,
                    userStatsAccountPublicKey: this.getUserStatsAccountPublicKey(),
                    accountSubscription: this.userAccountSubscriptionConfig,
                });
                await this.userStats.subscribe();
            }
            this.users.clear();
            success = await this.addAndSubscribeToUsers();
        }
        return success;
    }
    switchActiveUser(subAccountId, authority) {
        this.activeSubAccountId = subAccountId;
        this.authority = authority !== null && authority !== void 0 ? authority : this.authority;
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
    }
    async addUser(subAccountId, authority, userAccount) {
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userKey = this.getUserMapKey(subAccountId, authority);
        if (this.users.has(userKey) && this.users.get(userKey).isSubscribed) {
            return true;
        }
        const user = this.createUser(subAccountId, this.userAccountSubscriptionConfig, authority);
        const result = await user.subscribe(userAccount);
        if (result) {
            this.users.set(userKey, user);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Adds and subscribes to users based on params set by the constructor or by updateWallet.
     */
    async addAndSubscribeToUsers() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        // save the rpc calls if driftclient is initialized without a real wallet
        if (this.skipLoadUsers)
            return true;
        let result = true;
        if (this.authoritySubAccountMap && this.authoritySubAccountMap.size > 0) {
            this.authoritySubAccountMap.forEach(async (value, key) => {
                for (const subAccountId of value) {
                    result =
                        result && (await this.addUser(subAccountId, new web3_js_1.PublicKey(key)));
                }
            });
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_a = [...this.authoritySubAccountMap.values()][0][0]) !== null && _a !== void 0 ? _a : 0, new web3_js_1.PublicKey((_b = [...this.authoritySubAccountMap.keys()][0]) !== null && _b !== void 0 ? _b : this.authority.toString()));
            }
        }
        else {
            const userAccounts = (_c = (await this.getUserAccountsForAuthority(this.wallet.publicKey))) !== null && _c !== void 0 ? _c : [];
            let delegatedAccounts = [];
            if (this.includeDelegates) {
                delegatedAccounts =
                    (_d = (await this.getUserAccountsForDelegate(this.wallet.publicKey))) !== null && _d !== void 0 ? _d : [];
            }
            for (const account of userAccounts.concat(delegatedAccounts)) {
                result =
                    result &&
                        (await this.addUser(account.subAccountId, account.authority, account));
            }
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_f = (_e = userAccounts.concat(delegatedAccounts)[0]) === null || _e === void 0 ? void 0 : _e.subAccountId) !== null && _f !== void 0 ? _f : 0, (_h = (_g = userAccounts.concat(delegatedAccounts)[0]) === null || _g === void 0 ? void 0 : _g.authority) !== null && _h !== void 0 ? _h : this.authority);
            }
        }
        return result;
    }
    async initializeUserAccount(subAccountId = 0, name = userName_1.DEFAULT_USER_NAME, referrerInfo) {
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const tx = new web3_js_1.Transaction();
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                tx.add(await this.getInitializeUserStatsIx());
            }
        }
        tx.add(initializeUserAccountIx);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async getInitializeUserInstructions(subAccountId = 0, name = userName_1.DEFAULT_USER_NAME, referrerInfo) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, subAccountId);
        const remainingAccounts = new Array();
        if (referrerInfo !== undefined) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const state = this.getStateAccount();
        if (!state.whitelistMint.equals(web3_js_1.PublicKey.default)) {
            const associatedTokenPublicKey = await spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, state.whitelistMint, this.wallet.publicKey);
            remainingAccounts.push({
                pubkey: associatedTokenPublicKey,
                isWritable: false,
                isSigner: false,
            });
        }
        const nameBuffer = (0, userName_1.encodeName)(name);
        const initializeUserAccountIx = await this.program.instruction.initializeUser(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
            remainingAccounts,
        });
        return [userAccountPublicKey, initializeUserAccountIx];
    }
    async getInitializeUserStatsIx() {
        return await this.program.instruction.initializeUserStats({
            accounts: {
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
        });
    }
    async initializeReferrerName(name) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, 0);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        const tx = await this.program.transaction.initializeReferrerName(nameBuffer, {
            accounts: {
                referrerName: referrerNameAccountPublicKey,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserName(name, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const tx = await this.program.transaction.updateUserName(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserCustomMarginRatio(marginRatio, subAccountId = 0) {
        const tx = await this.program.transaction.updateUserCustomMarginRatio(subAccountId, marginRatio, {
            accounts: {
                user: await this.getUserAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserMarginTradingEnabled(marginTradingEnabled, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        await this.addUser(subAccountId, this.wallet.publicKey);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
        });
        const tx = await this.program.transaction.updateUserMarginTradingEnabled(subAccountId, marginTradingEnabled, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserDelegate(delegate, subAccountId = 0) {
        const tx = await this.program.transaction.updateUserDelegate(subAccountId, delegate, {
            accounts: {
                user: await this.getUserAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async fetchAllUserAccounts(includeIdle = true) {
        let filters = undefined;
        if (!includeIdle) {
            filters = [
                {
                    memcmp: {
                        offset: 4350,
                        bytes: bs58_1.default.encode(Uint8Array.from([0])),
                    },
                },
            ];
        }
        return (await this.program.account.user.all(filters));
    }
    async getUserAccountsForDelegate(delegate) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(delegate.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getUserAccountsAndAddressesForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount);
    }
    async getUserAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getReferredUserStatsAccountsByReferrer(referrer) {
        const programAccounts = await this.program.account.userStats.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(referrer.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async getReferrerNameAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.referrerName.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async deleteUser(subAccountId = 0, txParams) {
        var _a;
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const ix = await this.program.instruction.deleteUser({
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
            },
        });
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(ix, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        const userMapKey = this.getUserMapKey(subAccountId, this.wallet.publicKey);
        await ((_a = this.users.get(userMapKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe());
        this.users.delete(userMapKey);
        return txSig;
    }
    getUser(subAccountId, authority) {
        subAccountId = subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId;
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userMapKey = this.getUserMapKey(subAccountId, authority);
        if (!this.users.has(userMapKey)) {
            throw new Error(`Clearing House has no user for user id ${userMapKey}`);
        }
        return this.users.get(userMapKey);
    }
    getUsers() {
        // delegate users get added to the end
        return [...this.users.values()]
            .filter((acct) => acct.getUserAccount().authority.equals(this.wallet.publicKey))
            .concat([...this.users.values()].filter((acct) => !acct.getUserAccount().authority.equals(this.wallet.publicKey)));
    }
    getUserStats() {
        return this.userStats;
    }
    async fetchReferrerNameAccount(name) {
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        return (await this.program.account.referrerName.fetch(referrerNameAccountPublicKey));
    }
    getUserStatsAccountPublicKey() {
        if (this.userStatsAccountPublicKey) {
            return this.userStatsAccountPublicKey;
        }
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
        return this.userStatsAccountPublicKey;
    }
    async getUserAccountPublicKey(subAccountId, authority) {
        return this.getUser(subAccountId, authority).userAccountPublicKey;
    }
    getUserAccount(subAccountId, authority) {
        return this.getUser(subAccountId, authority).getUserAccount();
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param subAccountId
     */
    async forceGetUserAccount(subAccountId) {
        await this.getUser(subAccountId).fetchAccounts();
        return this.getUser(subAccountId).getUserAccount();
    }
    getUserAccountAndSlot(subAccountId) {
        return this.getUser(subAccountId).getUserAccountAndSlot();
    }
    getSpotPosition(marketIndex) {
        return this.getUserAccount().spotPositions.find((spotPosition) => spotPosition.marketIndex === marketIndex);
    }
    getQuoteAssetTokenAmount() {
        const spotMarket = this.getSpotMarketAccount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const spotPosition = this.getSpotPosition(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        return (0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarket, spotPosition.balanceType);
    }
    getTokenAmount(marketIndex) {
        const spotPosition = this.getSpotPosition(marketIndex);
        if (spotPosition === undefined) {
            return numericConstants_1.ZERO;
        }
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return (0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarket, spotPosition.balanceType);
    }
    getRemainingAccounts(params) {
        var _a;
        const { oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap } = this.getRemainingAccountMapsForUsers(params.userAccounts);
        if (params.useMarketLastSlotCache) {
            const lastUserSlot = (_a = this.getUserAccountAndSlot()) === null || _a === void 0 ? void 0 : _a.slot;
            for (const [marketIndex, slot,] of this.perpMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
                    perpMarketAccountMap.set(marketIndex, {
                        pubkey: perpMarketAccount.pubkey,
                        isSigner: false,
                        isWritable: false,
                    });
                    oracleAccountMap.set(perpMarketAccount.amm.oracle.toString(), {
                        pubkey: perpMarketAccount.amm.oracle,
                        isSigner: false,
                        isWritable: false,
                    });
                    const spotMarketAccount = this.getSpotMarketAccount(perpMarketAccount.quoteSpotMarketIndex);
                    spotMarketAccountMap.set(perpMarketAccount.quoteSpotMarketIndex, {
                        pubkey: spotMarketAccount.pubkey,
                        isSigner: false,
                        isWritable: false,
                    });
                    if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
                        oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                            pubkey: spotMarketAccount.oracle,
                            isSigner: false,
                            isWritable: false,
                        });
                    }
                }
                else {
                    this.perpMarketLastSlotCache.delete(marketIndex);
                }
            }
            for (const [marketIndex, slot,] of this.spotMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
                    spotMarketAccountMap.set(marketIndex, {
                        pubkey: spotMarketAccount.pubkey,
                        isSigner: false,
                        isWritable: false,
                    });
                    if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
                        oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                            pubkey: spotMarketAccount.oracle,
                            isSigner: false,
                            isWritable: false,
                        });
                    }
                }
                else {
                    this.spotMarketLastSlotCache.delete(marketIndex);
                }
            }
        }
        if (params.readablePerpMarketIndex !== undefined) {
            const perpMarketAccount = this.getPerpMarketAccount(params.readablePerpMarketIndex);
            perpMarketAccountMap.set(params.readablePerpMarketIndex, {
                pubkey: perpMarketAccount.pubkey,
                isSigner: false,
                isWritable: false,
            });
            oracleAccountMap.set(perpMarketAccount.amm.oracle.toString(), {
                pubkey: perpMarketAccount.amm.oracle,
                isSigner: false,
                isWritable: false,
            });
            const spotMarketAccount = this.getSpotMarketAccount(perpMarketAccount.quoteSpotMarketIndex);
            spotMarketAccountMap.set(perpMarketAccount.quoteSpotMarketIndex, {
                pubkey: spotMarketAccount.pubkey,
                isSigner: false,
                isWritable: false,
            });
            if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
                oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                    pubkey: spotMarketAccount.oracle,
                    isSigner: false,
                    isWritable: false,
                });
            }
        }
        if (params.readableSpotMarketIndexes !== undefined) {
            for (const readableSpotMarketIndex of params.readableSpotMarketIndexes) {
                const spotMarketAccount = this.getSpotMarketAccount(readableSpotMarketIndex);
                spotMarketAccountMap.set(readableSpotMarketIndex, {
                    pubkey: spotMarketAccount.pubkey,
                    isSigner: false,
                    isWritable: false,
                });
                if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
                    oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                        pubkey: spotMarketAccount.oracle,
                        isSigner: false,
                        isWritable: false,
                    });
                }
            }
        }
        if (params.writablePerpMarketIndexes !== undefined) {
            for (const writablePerpMarketIndex of params.writablePerpMarketIndexes) {
                const perpMarketAccount = this.getPerpMarketAccount(writablePerpMarketIndex);
                perpMarketAccountMap.set(writablePerpMarketIndex, {
                    pubkey: perpMarketAccount.pubkey,
                    isSigner: false,
                    isWritable: true,
                });
                oracleAccountMap.set(perpMarketAccount.amm.oracle.toString(), {
                    pubkey: perpMarketAccount.amm.oracle,
                    isSigner: false,
                    isWritable: false,
                });
                const spotMarketAccount = this.getSpotMarketAccount(perpMarketAccount.quoteSpotMarketIndex);
                spotMarketAccountMap.set(perpMarketAccount.quoteSpotMarketIndex, {
                    pubkey: spotMarketAccount.pubkey,
                    isSigner: false,
                    isWritable: false,
                });
                if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
                    oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                        pubkey: spotMarketAccount.oracle,
                        isSigner: false,
                        isWritable: false,
                    });
                }
            }
        }
        if (params.writableSpotMarketIndexes !== undefined) {
            for (const writableSpotMarketIndex of params.writableSpotMarketIndexes) {
                const spotMarketAccount = this.getSpotMarketAccount(writableSpotMarketIndex);
                spotMarketAccountMap.set(spotMarketAccount.marketIndex, {
                    pubkey: spotMarketAccount.pubkey,
                    isSigner: false,
                    isWritable: true,
                });
                if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
                    oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                        pubkey: spotMarketAccount.oracle,
                        isSigner: false,
                        isWritable: false,
                    });
                }
            }
        }
        return [
            ...oracleAccountMap.values(),
            ...spotMarketAccountMap.values(),
            ...perpMarketAccountMap.values(),
        ];
    }
    getRemainingAccountMapsForUsers(userAccounts) {
        const oracleAccountMap = new Map();
        const spotMarketAccountMap = new Map();
        const perpMarketAccountMap = new Map();
        for (const userAccount of userAccounts) {
            for (const spotPosition of userAccount.spotPositions) {
                if (!(0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                    const spotMarket = this.getSpotMarketAccount(spotPosition.marketIndex);
                    spotMarketAccountMap.set(spotPosition.marketIndex, {
                        pubkey: spotMarket.pubkey,
                        isSigner: false,
                        isWritable: false,
                    });
                    if (!spotMarket.oracle.equals(web3_js_1.PublicKey.default)) {
                        oracleAccountMap.set(spotMarket.oracle.toString(), {
                            pubkey: spotMarket.oracle,
                            isSigner: false,
                            isWritable: false,
                        });
                    }
                    if (!spotPosition.openAsks.eq(numericConstants_1.ZERO) ||
                        !spotPosition.openBids.eq(numericConstants_1.ZERO)) {
                        const quoteSpotMarket = this.getQuoteSpotMarketAccount();
                        spotMarketAccountMap.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, {
                            pubkey: quoteSpotMarket.pubkey,
                            isSigner: false,
                            isWritable: false,
                        });
                        if (!quoteSpotMarket.oracle.equals(web3_js_1.PublicKey.default)) {
                            oracleAccountMap.set(quoteSpotMarket.oracle.toString(), {
                                pubkey: quoteSpotMarket.oracle,
                                isSigner: false,
                                isWritable: false,
                            });
                        }
                    }
                }
            }
            for (const position of userAccount.perpPositions) {
                if (!(0, position_1.positionIsAvailable)(position)) {
                    const perpMarketAccount = this.getPerpMarketAccount(position.marketIndex);
                    perpMarketAccountMap.set(position.marketIndex, {
                        pubkey: perpMarketAccount.pubkey,
                        isWritable: false,
                        isSigner: false,
                    });
                    oracleAccountMap.set(perpMarketAccount.amm.oracle.toString(), {
                        pubkey: perpMarketAccount.amm.oracle,
                        isWritable: false,
                        isSigner: false,
                    });
                    const spotMarketAccount = this.getSpotMarketAccount(perpMarketAccount.quoteSpotMarketIndex);
                    spotMarketAccountMap.set(perpMarketAccount.quoteSpotMarketIndex, {
                        pubkey: spotMarketAccount.pubkey,
                        isSigner: false,
                        isWritable: false,
                    });
                    if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
                        oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                            pubkey: spotMarketAccount.oracle,
                            isSigner: false,
                            isWritable: false,
                        });
                    }
                }
            }
        }
        return {
            oracleAccountMap,
            spotMarketAccountMap,
            perpMarketAccountMap,
        };
    }
    getOrder(orderId) {
        var _a;
        return (_a = this.getUserAccount()) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.orderId === orderId);
    }
    getOrderByUserId(userOrderId) {
        var _a;
        return (_a = this.getUserAccount()) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.userOrderId === userOrderId);
    }
    async deposit(amount, marketIndex, collateralAccountPublicKey, subAccountId, reduceOnly = false) {
        const tx = new web3_js_1.Transaction();
        tx.add(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: 600000,
        }));
        const additionalSigners = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const signerAuthority = this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(signerAuthority);
        if (createWSOLTokenAccount) {
            const { ixs, signers, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true);
            collateralAccountPublicKey = pubkey;
            ixs.forEach((ix) => {
                tx.add(ix);
            });
            signers.forEach((signer) => additionalSigners.push(signer));
        }
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, collateralAccountPublicKey, subAccountId, reduceOnly, true);
        tx.add(depositCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            tx.add(spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, collateralAccountPublicKey, signerAuthority, signerAuthority, []));
        }
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, reduceOnly = false, userInitialized = true) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        let remainingAccounts = [];
        if (userInitialized) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [await this.forceGetUserAccount()],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [],
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.deposit(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
    }
    async checkIfAccountExists(account) {
        try {
            const accountInfo = await this.connection.getAccountInfo(account);
            return accountInfo != null;
        }
        catch (e) {
            // Doesn't already exist
            return false;
        }
    }
    async getWrappedSolAccountCreationIxs(amount, includeRent) {
        const wrappedSolAccount = new web3_js_1.Keypair();
        const result = {
            ixs: [],
            signers: [],
            pubkey: wrappedSolAccount.publicKey,
        };
        const rentSpaceLamports = new anchor_1.BN(web3_js_1.LAMPORTS_PER_SOL / 100);
        const lamports = includeRent
            ? amount.add(rentSpaceLamports)
            : rentSpaceLamports;
        const authority = this.wallet.publicKey;
        result.ixs.push(web3_js_1.SystemProgram.createAccount({
            fromPubkey: authority,
            newAccountPubkey: wrappedSolAccount.publicKey,
            lamports: lamports.toNumber(),
            space: 165,
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }));
        result.ixs.push(spl_token_1.Token.createInitAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, spotMarkets_1.WRAPPED_SOL_MINT, wrappedSolAccount.publicKey, authority));
        result.signers.push(wrappedSolAccount);
        return result;
    }
    getAssociatedTokenAccountCreationIx(tokenMintAddress, associatedTokenAddress) {
        const createAssociatedAccountIx = spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenMintAddress, associatedTokenAddress, this.wallet.publicKey, this.wallet.publicKey);
        return createAssociatedAccountIx;
    }
    /**
     * Creates the Clearing House User account for a user, and deposits some initial collateral
     * @param amount
     * @param userTokenAccount
     * @param marketIndex
     * @param subAccountId
     * @param name
     * @param fromSubAccountId
     * @returns
     */
    async initializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name = userName_1.DEFAULT_USER_NAME, fromSubAccountId, referrerInfo, txParams) {
        var _a;
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const additionalSigners = [];
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarket.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const tx = new web3_js_1.Transaction();
        tx.add(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: (_a = txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits) !== null && _a !== void 0 ? _a : 600000,
        }));
        if (txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice) {
            tx.add(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: txParams.computeUnitsPrice,
            }));
        }
        const authority = this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && userTokenAccount.equals(authority);
        if (createWSOLTokenAccount) {
            const { ixs: startIxs, signers, pubkey, } = await this.getWrappedSolAccountCreationIxs(amount, true);
            userTokenAccount = pubkey;
            startIxs.forEach((ix) => {
                tx.add(ix);
            });
            signers.forEach((signer) => additionalSigners.push(signer));
        }
        const depositCollateralIx = fromSubAccountId != null
            ? await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, subAccountId)
            : await this.getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, false, false);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                tx.add(await this.getInitializeUserStatsIx());
            }
        }
        tx.add(initializeUserAccountIx).add(depositCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            tx.add(spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, userTokenAccount, authority, authority, []));
        }
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async initializeUserAccountForDevnet(subAccountId = 0, name = userName_1.DEFAULT_USER_NAME, marketIndex, tokenFaucet, amount, referrerInfo) {
        const [associateTokenPublicKey, createAssociatedAccountIx, mintToIx] = await tokenFaucet.createAssociatedTokenAccountAndMintToInstructions(this.wallet.publicKey, amount);
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, associateTokenPublicKey, subAccountId, false, false);
        const tx = new web3_js_1.Transaction().add(createAssociatedAccountIx).add(mintToIx);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                tx.add(await this.getInitializeUserStatsIx());
            }
        }
        tx.add(initializeUserAccountIx).add(depositCollateralIx);
        const txSig = await this.program.provider.sendAndConfirm(tx, []);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async withdraw(amount, marketIndex, userTokenAccount, reduceOnly = false) {
        const tx = new web3_js_1.Transaction();
        tx.add(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: 600000,
        }));
        const additionalSigners = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const authority = this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && userTokenAccount.equals(authority);
        if (createWSOLTokenAccount) {
            const { ixs, signers, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, false);
            userTokenAccount = pubkey;
            ixs.forEach((ix) => {
                tx.add(ix);
            });
            signers.forEach((signer) => additionalSigners.push(signer));
        }
        else {
            const accountExists = await this.checkIfAccountExists(userTokenAccount);
            if (!accountExists) {
                const createAssociatedTokenAccountIx = this.getAssociatedTokenAccountCreationIx(spotMarketAccount.mint, userTokenAccount);
                tx.add(createAssociatedTokenAccountIx);
            }
        }
        const withdrawCollateral = await this.getWithdrawIx(amount, spotMarketAccount.marketIndex, userTokenAccount, reduceOnly);
        tx.add(withdrawCollateral);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            tx.add(spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, userTokenAccount, authority, authority, []));
        }
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getWithdrawIx(amount, marketIndex, userTokenAccount, reduceOnly = false) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.withdraw(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
    }
    async transferDeposit(amount, marketIndex, fromSubAccountId, toSubAccountId, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        if (fromSubAccountId === this.activeSubAccountId ||
            toSubAccountId === this.activeSubAccountId) {
            this.spotMarketLastSlotCache.set(marketIndex, slot);
        }
        return txSig;
    }
    async getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId) {
        const fromUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, fromSubAccountId);
        const toUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, toSubAccountId);
        let remainingAccounts;
        const userMapKey = this.getUserMapKey(fromSubAccountId, this.wallet.publicKey);
        if (this.users.has(userMapKey)) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [this.users.get(userMapKey).getUserAccount()],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.authority, fromSubAccountId);
            const fromUserAccount = (await this.program.account.user.fetch(userAccountPublicKey));
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [fromUserAccount],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        return await this.program.instruction.transferDeposit(marketIndex, amount, {
            accounts: {
                authority: this.wallet.publicKey,
                fromUser,
                toUser,
                userStats: this.getUserStatsAccountPublicKey(),
                state: await this.getStatePublicKey(),
                spotMarketVault: this.getSpotMarketAccount(marketIndex).vault,
            },
            remainingAccounts,
        });
    }
    async updateSpotMarketCumulativeInterest(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.updateSpotMarketCumulativeInterestIx(marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async updateSpotMarketCumulativeInterestIx(marketIndex) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.updateSpotMarketCumulativeInterest({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                oracle: spotMarket.oracle,
            },
        });
    }
    async settleLP(settleeUserAccountPublicKey, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.settleLPIx(settleeUserAccountPublicKey, marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async settleLPIx(settleeUserAccountPublicKey, marketIndex) {
        const settleeUserAccount = (await this.program.account.user.fetch(settleeUserAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.settleLp(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: settleeUserAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async removePerpLpShares(marketIndex, sharesToBurn, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getRemovePerpLpSharesIx(marketIndex, sharesToBurn), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async removePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpSharesInExpiringMarket(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getRemovePerpLpSharesIx(marketIndex, sharesToBurn) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const userAccount = this.getUserAccount();
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpShares(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async addPerpLpShares(amount, marketIndex, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getAddPerpLpSharesIx(amount, marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getAddPerpLpSharesIx(amount, marketIndex) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.addPerpLpShares(amount, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async openPosition(direction, amount, marketIndex, limitPrice) {
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction,
            baseAssetAmount: amount,
            price: limitPrice,
        });
    }
    async sendSignedTx(tx) {
        const { txSig } = await this.sendTransaction(tx, undefined, this.opts, true);
        return txSig;
    }
    /**
     * Sends a market order and returns a signed tx which can fill the order against the vamm, which the caller can use to fill their own order if required.
     * @param orderParams
     * @param userAccountPublicKey
     * @param userAccount
     * @param makerInfo
     * @param txParams
     * @param bracketOrdersParams
     * @returns
     */
    async sendMarketOrderAndGetSignedFillTx(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams = new Array(), referrerInfo) {
        var _a, _b;
        const marketIndex = orderParams.marketIndex;
        const orderId = userAccount.nextOrderId;
        const bracketOrderIxs = [];
        const placePerpOrderIx = await this.getPlacePerpOrderIx(orderParams);
        for (const bracketOrderParams of bracketOrdersParams) {
            const placeBracketOrderIx = await this.getPlacePerpOrderIx(bracketOrderParams);
            bracketOrderIxs.push(placeBracketOrderIx);
        }
        const fillPerpOrderIx = await this.getFillPerpOrderIx(userAccountPublicKey, userAccount, {
            orderId,
            marketIndex,
        }, makerInfo, referrerInfo);
        const lookupTableAccount = await this.fetchMarketLookupTableAccount();
        const walletSupportsVersionedTxns = 
        //@ts-ignore
        (_b = (_a = this.wallet.supportedTransactionVersions) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0 > 1;
        // use versioned transactions if there is a lookup table account and wallet is compatible
        if (walletSupportsVersionedTxns && lookupTableAccount) {
            const versionedMarketOrderTx = await this.txSender.getVersionedTransaction([placePerpOrderIx].concat(bracketOrderIxs), [lookupTableAccount], [], this.opts);
            const versionedFillTx = await this.txSender.getVersionedTransaction([fillPerpOrderIx], [lookupTableAccount], [], this.opts);
            const [signedVersionedMarketOrderTx, signedVersionedFillTx] = await this.provider.wallet.signAllTransactions([
                //@ts-ignore
                versionedMarketOrderTx,
                //@ts-ignore
                versionedFillTx,
            ]);
            const { txSig, slot } = await this.txSender.sendRawTransaction(signedVersionedMarketOrderTx.serialize(), this.opts);
            this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
            return { txSig, signedFillTx: signedVersionedFillTx };
        }
        else {
            const marketOrderTx = (0, utils_1.wrapInTx)(placePerpOrderIx, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice);
            if (bracketOrderIxs.length > 0) {
                marketOrderTx.add(...bracketOrderIxs);
            }
            const fillTx = (0, utils_1.wrapInTx)(fillPerpOrderIx, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice);
            // Apply the latest blockhash to the txs so that we can sign before sending them
            const currentBlockHash = (await this.connection.getLatestBlockhash('finalized')).blockhash;
            marketOrderTx.recentBlockhash = currentBlockHash;
            fillTx.recentBlockhash = currentBlockHash;
            marketOrderTx.feePayer = userAccount.authority;
            fillTx.feePayer = userAccount.authority;
            const [signedMarketOrderTx, signedFillTx] = await this.provider.wallet.signAllTransactions([marketOrderTx, fillTx]);
            const { txSig, slot } = await this.sendTransaction(signedMarketOrderTx, [], this.opts, true);
            this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
            return { txSig, signedFillTx };
        }
    }
    async placePerpOrder(orderParams, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getPlacePerpOrderIx(orderParams), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    getOrderParams(optionalOrderParams, marketType) {
        return Object.assign({}, types_1.DefaultOrderParams, optionalOrderParams, {
            marketType,
        });
    }
    async getPlacePerpOrderIx(orderParams) {
        orderParams = this.getOrderParams(orderParams, types_1.MarketType.PERP);
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            readablePerpMarketIndex: orderParams.marketIndex,
        });
        return await this.program.instruction.placePerpOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateAMMs(marketIndexes, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getUpdateAMMsIx(marketIndexes), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getUpdateAMMsIx(marketIndexes) {
        for (let i = marketIndexes.length; i < 5; i++) {
            marketIndexes.push(100);
        }
        const marketAccountInfos = [];
        const oracleAccountInfos = [];
        for (const marketIndex of marketIndexes) {
            if (marketIndex !== 100) {
                const market = this.getPerpMarketAccount(marketIndex);
                marketAccountInfos.push({
                    pubkey: market.pubkey,
                    isWritable: true,
                    isSigner: false,
                });
                oracleAccountInfos.push({
                    pubkey: market.amm.oracle,
                    isWritable: false,
                    isSigner: false,
                });
            }
        }
        const remainingAccounts = oracleAccountInfos.concat(marketAccountInfos);
        return await this.program.instruction.updateAmms(marketIndexes, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarket(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getSettleExpiredMarketIx(marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getSettleExpiredMarketIx(marketIndex) {
        const marketAccountInfos = [];
        const oracleAccountInfos = [];
        const spotMarketAccountInfos = [];
        const market = this.getPerpMarketAccount(marketIndex);
        marketAccountInfos.push({
            pubkey: market.pubkey,
            isWritable: true,
            isSigner: false,
        });
        oracleAccountInfos.push({
            pubkey: market.amm.oracle,
            isWritable: false,
            isSigner: false,
        });
        spotMarketAccountInfos.push({
            pubkey: this.getSpotMarketAccount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX).pubkey,
            isSigner: false,
            isWritable: true,
        });
        const remainingAccounts = oracleAccountInfos
            .concat(spotMarketAccountInfos)
            .concat(marketAccountInfos);
        return await this.program.instruction.settleExpiredMarket(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarketPoolsToRevenuePool(perpMarketIndex, txParams) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        const spotMarketPublicKey = await (0, pda_1.getSpotMarketPublicKey)(this.program.programId, numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const ix = await this.program.instruction.settleExpiredMarketPoolsToRevenuePool({
            accounts: {
                state: await this.getStatePublicKey(),
                admin: this.wallet.publicKey,
                spotMarket: spotMarketPublicKey,
                perpMarket: perpMarketPublicKey,
            },
        });
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(ix, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async cancelOrder(orderId, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getCancelOrderIx(orderId), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getCancelOrderIx(orderId) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrder(orderId !== null && orderId !== void 0 ? orderId : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelOrderByUserId(userOrderId, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getCancelOrderByUserIdIx(userOrderId), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getCancelOrderByUserIdIx(userOrderId) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const order = this.getOrderByUserId(userOrderId);
        const oracle = this.getPerpMarketAccount(order.marketIndex).amm.oracle;
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrderByUserId(userOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
                oracle,
            },
            remainingAccounts,
        });
    }
    async cancelOrders(marketType, marketIndex, direction, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getCancelOrdersIx(marketType, marketIndex, direction), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getCancelOrdersIx(marketType, marketIndex, direction) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        let readablePerpMarketIndex = undefined;
        let readableSpotMarketIndexes = undefined;
        if (marketIndex) {
            if (marketType && (0, types_1.isVariant)(marketType, 'perp')) {
                readablePerpMarketIndex = marketIndex;
            }
            else if (marketType && (0, types_1.isVariant)(marketType, 'spot')) {
                readableSpotMarketIndexes = [marketIndex];
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrders(marketType !== null && marketType !== void 0 ? marketType : null, marketIndex !== null && marketIndex !== void 0 ? marketIndex : null, direction !== null && direction !== void 0 ? direction : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelAndPlaceOrders(cancelOrderParams, placeOrderParams, txParams) {
        const tx = (0, utils_1.wrapInTx)(await this.getCancelOrdersIx(cancelOrderParams.marketType, cancelOrderParams.marketIndex, cancelOrderParams.direction), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice);
        for (const placeOrderParam of placeOrderParams) {
            const marketType = placeOrderParam.marketType;
            if (!marketType) {
                throw new Error('marketType must be set on placeOrderParams');
            }
            let ix;
            if ((0, types_1.isVariant)(marketType, 'perp')) {
                ix = this.getPlacePerpOrderIx(placeOrderParam);
            }
            else {
                ix = this.getPlaceSpotOrderIx(placeOrderParam);
            }
            tx.add(ix);
        }
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async fillPerpOrder(userAccountPublicKey, user, order, makerInfo, referrerInfo, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getFillPerpOrderIx(userAccountPublicKey, user, order, makerInfo, referrerInfo), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getFillPerpOrderIx(userAccountPublicKey, userAccount, order, makerInfo, referrerInfo) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const fillerPublicKey = await this.getUserAccountPublicKey();
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [userAccount];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writablePerpMarketIndexes: [marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        const orderId = order.orderId;
        return await this.program.instruction.fillPerpOrder(orderId, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler: fillerPublicKey,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async getRevertFillIx() {
        const fillerPublicKey = await this.getUserAccountPublicKey();
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        return this.program.instruction.revertFill({
            accounts: {
                state: await this.getStatePublicKey(),
                filler: fillerPublicKey,
                fillerStats: fillerStatsPublicKey,
                authority: this.wallet.publicKey,
            },
        });
    }
    async placeSpotOrder(orderParams, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getPlaceSpotOrderIx(orderParams), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceSpotOrderIx(orderParams) {
        orderParams = this.getOrderParams(orderParams, types_1.MarketType.SPOT);
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            readableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        return await this.program.instruction.placeSpotOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async fillSpotOrder(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getFillSpotOrderIx(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getFillSpotOrderIx(userAccountPublicKey, userAccount, order, fulfillmentConfig, makerInfo, referrerInfo) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const fillerPublicKey = await this.getUserAccountPublicKey();
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        const userAccounts = [userAccount];
        if (makerInfo !== undefined) {
            userAccounts.push(makerInfo.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        if (makerInfo) {
            remainingAccounts.push({
                pubkey: makerInfo.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: makerInfo.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const orderId = order.orderId;
        const makerOrderId = makerInfo ? makerInfo.order.orderId : null;
        this.addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.fillSpotOrder(orderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, makerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler: fillerPublicKey,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        if (fulfillmentConfig) {
            if ('serumProgramId' in fulfillmentConfig) {
                this.addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else if ('phoenixProgramId' in fulfillmentConfig) {
                this.addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else {
                throw Error('Invalid fulfillment config type');
            }
        }
        else {
            remainingAccounts.push({
                pubkey: this.getSpotMarketAccount(marketIndex).vault,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: this.getQuoteSpotMarketAccount().vault,
                isWritable: false,
                isSigner: false,
            });
        }
    }
    addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumRequestQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumEventQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBids,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumAsks,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumOpenOrders,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: (0, pda_1.getSerumSignerPublicKey)(fulfillmentConfig.serumProgramId, fulfillmentConfig.serumMarket, fulfillmentConfig.serumSignerNonce),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getStateAccount().srmVault,
            isWritable: false,
            isSigner: false,
        });
    }
    addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixLogAuthority,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
    }
    async triggerOrder(userAccountPublicKey, user, order, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getTriggerOrderIx(userAccountPublicKey, user, order), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getTriggerOrderIx(userAccountPublicKey, userAccount, order) {
        const fillerPublicKey = await this.getUserAccountPublicKey();
        let remainingAccountsParams;
        if ((0, types_1.isVariant)(order.marketType, 'perp')) {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writablePerpMarketIndexes: [order.marketIndex],
            };
        }
        else {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writableSpotMarketIndexes: [order.marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
            };
        }
        const remainingAccounts = this.getRemainingAccounts(remainingAccountsParams);
        const orderId = order.orderId;
        return await this.program.instruction.triggerOrder(orderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler: fillerPublicKey,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async forceCancelOrders(userAccountPublicKey, user, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getForceCancelOrdersIx(userAccountPublicKey, user), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getForceCancelOrdersIx(userAccountPublicKey, userAccount) {
        const fillerPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.forceCancelOrders({
            accounts: {
                state: await this.getStatePublicKey(),
                filler: fillerPublicKey,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserIdle(userAccountPublicKey, user, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getUpdateUserIdleIx(userAccountPublicKey, user), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getUpdateUserIdleIx(userAccountPublicKey, userAccount) {
        const fillerPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserIdle({
            accounts: {
                state: await this.getStatePublicKey(),
                filler: fillerPublicKey,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndTakePerpOrder(orderParams, makerInfo, referrerInfo, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo) {
        orderParams = this.getOrderParams(orderParams, types_1.MarketType.PERP);
        const userStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [this.getUserAccount()];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        return await this.program.instruction.placeAndTakePerpOrder(orderParams, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndMakePerpOrder(orderParams, takerInfo, referrerInfo, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo) {
        orderParams = this.getOrderParams(orderParams, types_1.MarketType.PERP);
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), takerInfo.takerUserAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const takerOrderId = takerInfo.order.orderId;
        return await this.program.instruction.placeAndMakePerpOrder(orderParams, takerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo) {
        orderParams = this.getOrderParams(orderParams, types_1.MarketType.SPOT);
        const userStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const userAccounts = [this.getUserAccount()];
        if (makerInfo !== undefined) {
            userAccounts.push(makerInfo.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        let makerOrderId = null;
        if (makerInfo) {
            makerOrderId = makerInfo.order.orderId;
            remainingAccounts.push({
                pubkey: makerInfo.maker,
                isSigner: false,
                isWritable: true,
            });
            remainingAccounts.push({
                pubkey: makerInfo.makerStats,
                isSigner: false,
                isWritable: true,
            });
        }
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.placeAndTakeSpotOrder(orderParams, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, makerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndMakeSpotOrder(orderParams, takerInfo, fulfillmentConfig, referrerInfo, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo) {
        orderParams = this.getOrderParams(orderParams, types_1.MarketType.SPOT);
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), takerInfo.takerUserAccount],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        const takerOrderId = takerInfo.order.orderId;
        return await this.program.instruction.placeAndMakeSpotOrder(orderParams, takerOrderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /**
     * Close an entire position. If you want to reduce a position, use the {@link openPosition} method in the opposite direction of the current position.
     * @param marketIndex
     * @returns
     */
    async closePosition(marketIndex, limitPrice) {
        const userPosition = this.getUser().getPerpPosition(marketIndex);
        if (!userPosition) {
            throw Error(`No position in market ${marketIndex.toString()}`);
        }
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction: (0, position_1.findDirectionToClose)(userPosition),
            baseAssetAmount: userPosition.baseAssetAmount.abs(),
            reduceOnly: true,
            price: limitPrice,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrder instead
     * @param orderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrder(orderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrder({
            orderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrderByUserOrderId instead
     * @param userOrderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrderByUserOrderId(userOrderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrderByUserOrderId({
            userOrderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order (spot or perp) by closing it and replacing it with a new order.
     * @param orderId: The open order to modify
     * @param newDirection: The new direction for the order
     * @param newBaseAmount: The new base amount for the order
     * @param newLimitPice: The new limit price for the order
     * @param newOraclePriceOffset: The new oracle price offset for the order
     * @param newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param auctionDuration:
     * @param auctionStartPrice:
     * @param auctionEndPrice:
     * @param reduceOnly:
     * @param postOnly:
     * @param immediateOrCancel:
     * @param maxTs:
     * @returns
     */
    async modifyOrder({ orderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, txParams, }) {
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || null,
            auctionStartPrice: auctionStartPrice || null,
            auctionEndPrice: auctionEndPrice || null,
            reduceOnly: reduceOnly || null,
            postOnly: postOnly || null,
            immediateOrCancel: immediateOrCancel || null,
            maxTs: maxTs || null,
        };
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getModifyOrderIx(orderId, orderParams), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getModifyOrderIx(orderId, orderParams) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.modifyOrder(orderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @param userOrderId: The open order to modify
     * @param newDirection: The new direction for the order
     * @param newBaseAmount: The new base amount for the order
     * @param newLimitPice: The new limit price for the order
     * @param newOraclePriceOffset: The new oracle price offset for the order
     * @param newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param auctionDuration: Only required if order type changed to market from something else
     * @param auctionStartPrice: Only required if order type changed to market from something else
     * @param auctionEndPrice: Only required if order type changed to market from something else
     * @param reduceOnly:
     * @param postOnly:
     * @param immediateOrCancel:
     * @param maxTs:
     * @returns
     */
    async modifyOrderByUserOrderId({ userOrderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, txParams, }) {
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || null,
            auctionStartPrice: auctionStartPrice || null,
            auctionEndPrice: auctionEndPrice || null,
            reduceOnly: reduceOnly || null,
            postOnly: postOnly || null,
            immediateOrCancel: immediateOrCancel || null,
            maxTs: maxTs || null,
        };
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getModifyOrderByUserIdIx(userOrderId, orderParams), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getModifyOrderByUserIdIx(userOrderId, orderParams) {
        const userAccountPublicKey = await this.getUserAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.modifyOrderByUserId(userOrderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settlePNLs(users, marketIndexes) {
        const ixs = [];
        for (const { settleeUserAccountPublicKey, settleeUserAccount } of users) {
            for (const marketIndex of marketIndexes) {
                ixs.push(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex));
            }
        }
        const tx = new web3_js_1.Transaction()
            .add(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: 1000000,
        }))
            .add(...ixs);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async settlePNL(settleeUserAccountPublicKey, settleeUserAccount, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.settlePnl(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: settleeUserAccountPublicKey,
                spotMarketVault: this.getQuoteSpotMarketAccount().vault,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerp(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidatorPublicKey = await this.getUserAccountPublicKey();
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), userAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return await this.program.instruction.liquidatePerp(marketIndex, maxBaseAssetAmount, limitPrice !== null && limitPrice !== void 0 ? limitPrice : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator: liquidatorPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidateSpot(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidatorPublicKey = await this.getUserAccountPublicKey();
        const liquidatorStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), userAccount],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [liabilityMarketIndex, assetMarketIndex],
        });
        return await this.program.instruction.liquidateSpot(assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator: liquidatorPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidateBorrowForPerpPnl(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidatorPublicKey = await this.getUserAccountPublicKey();
        const liquidatorStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [liabilityMarketIndex],
        });
        return await this.program.instruction.liquidateBorrowForPerpPnl(perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator: liquidatorPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerpPnlForDeposit(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, txParams) {
        const { txSig, slot } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidatorPublicKey = await this.getUserAccountPublicKey();
        const liquidatorStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [assetMarketIndex],
        });
        return await this.program.instruction.liquidatePerpPnlForDeposit(perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator: liquidatorPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolvePerpBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidatorPublicKey = await this.getUserAccountPublicKey();
        const liquidatorStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), userAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarket = this.getQuoteSpotMarketAccount();
        return await this.program.instruction.resolvePerpBankruptcy(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator: liquidatorPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolveSpotBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidatorPublicKey = await this.getUserAccountPublicKey();
        const liquidatorStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(), userAccount],
            writableSpotMarketIndexes: [marketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.resolveSpotBankruptcy(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                liquidator: liquidatorPublicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async updateFundingRate(perpMarketIndex, oracle, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getUpdateFundingRateIx(perpMarketIndex, oracle), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getUpdateFundingRateIx(perpMarketIndex, oracle) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        return await this.program.instruction.updateFundingRate(perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarketPublicKey,
                oracle: oracle,
            },
        });
    }
    async settleFundingPayment(userAccountPublicKey, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getSettleFundingPaymentIx(userAccountPublicKey), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getSettleFundingPaymentIx(userAccountPublicKey) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const writablePerpMarketIndexes = [];
        for (const position of userAccount.perpPositions) {
            if (!(0, position_1.positionIsAvailable)(position)) {
                writablePerpMarketIndexes.push(position.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writablePerpMarketIndexes,
        });
        return await this.program.instruction.settleFundingPayment({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts,
        });
    }
    triggerEvent(eventName, data) {
        this.eventEmitter.emit(eventName, data);
    }
    getOracleDataForPerpMarket(marketIndex) {
        const oracleKey = this.getPerpMarketAccount(marketIndex).amm.oracle;
        const oracleData = this.getOraclePriceDataAndSlot(oracleKey).data;
        return oracleData;
    }
    getOracleDataForSpotMarket(marketIndex) {
        const oracleKey = this.getSpotMarketAccount(marketIndex).oracle;
        const oracleData = this.getOraclePriceDataAndSlot(oracleKey).data;
        return oracleData;
    }
    async initializeInsuranceFundStake(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getInitializeInsuranceFundStakeIx(marketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getInitializeInsuranceFundStakeIx(marketIndex) {
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        return await this.program.instruction.initializeInsuranceFundStake(marketIndex, {
            accounts: {
                insuranceFundStake: ifStakeAccountPublicKey,
                spotMarket: this.getSpotMarketAccount(marketIndex).pubkey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
        });
    }
    async getAddInsuranceFundStakeIx(marketIndex, amount, collateralAccountPublicKey) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const ix = this.program.instruction.addInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: collateralAccountPublicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
        return ix;
    }
    /**
     * Add to an insurance fund stake and optionally initialize the account
     */
    async addInsuranceFundStake({ marketIndex, amount, collateralAccountPublicKey, initializeStakeAccount, fromSubaccount, }) {
        const tx = new web3_js_1.Transaction();
        const additionalSigners = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        let tokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs, signers, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                tx.add(ix);
            });
            signers.forEach((signer) => additionalSigners.push(signer));
        }
        else {
            tokenAccount = collateralAccountPublicKey;
        }
        if (fromSubaccount) {
            const withdrawIx = await this.getWithdrawIx(amount, marketIndex, tokenAccount);
            tx.add(withdrawIx);
        }
        if (initializeStakeAccount) {
            const initializeIx = await this.getInitializeInsuranceFundStakeIx(marketIndex);
            tx.add(initializeIx);
        }
        const addFundsIx = await this.getAddInsuranceFundStakeIx(marketIndex, amount, tokenAccount);
        tx.add(addFundsIx);
        if (createWSOLTokenAccount) {
            tx.add(spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    async requestRemoveInsuranceFundStake(marketIndex, amount) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const tx = await this.program.transaction.requestRemoveInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
            remainingAccounts,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async cancelRequestRemoveInsuranceFundStake(marketIndex) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const tx = await this.program.transaction.cancelRequestRemoveInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
            remainingAccounts,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async removeInsuranceFundStake(marketIndex, collateralAccountPublicKey) {
        const tx = new web3_js_1.Transaction();
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const additionalSigners = [];
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        let tokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs, signers, pubkey } = await this.getWrappedSolAccountCreationIxs(numericConstants_1.ZERO, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                tx.add(ix);
            });
            signers.forEach((signer) => additionalSigners.push(signer));
        }
        else {
            tokenAccount = collateralAccountPublicKey;
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const removeStakeIx = await this.program.instruction.removeInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: tokenAccount,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
        tx.add(removeStakeIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            tx.add(spl_token_1.Token.createCloseAccountInstruction(spl_token_1.TOKEN_PROGRAM_ID, tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    async settleRevenueToInsuranceFund(marketIndex) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
        });
        const tx = await this.program.transaction.settleRevenueToInsuranceFund(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction((0, utils_1.wrapInTx)(await this.getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex), txParams === null || txParams === void 0 ? void 0 : txParams.computeUnits, txParams === null || txParams === void 0 ? void 0 : txParams.computeUnitsPrice), [], this.opts);
        return txSig;
    }
    async getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [spotMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(spotMarketIndex);
        return await this.program.instruction.resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    getPerpMarketExtendedInfo(marketIndex) {
        var _a, _b;
        const marketAccount = this.getPerpMarketAccount(marketIndex);
        const quoteAccount = this.getSpotMarketAccount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const extendedInfo = {
            marketIndex,
            minOrderSize: (_a = marketAccount.amm) === null || _a === void 0 ? void 0 : _a.minOrderSize,
            marginMaintenance: marketAccount.marginRatioMaintenance,
            pnlPoolValue: (0, spotBalance_1.getTokenAmount)((_b = marketAccount.pnlPool) === null || _b === void 0 ? void 0 : _b.scaledBalance, quoteAccount, types_1.SpotBalanceType.DEPOSIT),
            contractTier: marketAccount.contractTier,
            availableInsurance: (0, market_1.calculateMarketMaxAvailableInsurance)(marketAccount, quoteAccount),
        };
        return extendedInfo;
    }
    /**
     * Returns the market index and type for a given market name
     * E.g. "SOL-PERP" -> { marketIndex: 0, marketType: MarketType.PERP }
     *
     * @param name
     */
    getMarketIndexAndType(name) {
        for (const perpMarketAccount of this.getPerpMarketAccounts()) {
            if ((0, userName_1.decodeName)(perpMarketAccount.name) === name) {
                return {
                    marketIndex: perpMarketAccount.marketIndex,
                    marketType: types_1.MarketType.PERP,
                };
            }
        }
        for (const spotMarketAccount of this.getSpotMarketAccounts()) {
            if ((0, userName_1.decodeName)(spotMarketAccount.name) === name) {
                return {
                    marketIndex: spotMarketAccount.marketIndex,
                    marketType: types_1.MarketType.SPOT,
                };
            }
        }
        return undefined;
    }
    sendTransaction(tx, additionalSigners, opts, preSigned) {
        return this.txSender.send(tx, additionalSigners, opts, preSigned);
    }
}
exports.DriftClient = DriftClient;
