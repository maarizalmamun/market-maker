"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const types_1 = require("./types");
const position_1 = require("./math/position");
const numericConstants_1 = require("./constants/numericConstants");
const _1 = require(".");
const spotBalance_1 = require("./math/spotBalance");
const amm_1 = require("./math/amm");
const margin_1 = require("./math/margin");
const pollingUserAccountSubscriber_1 = require("./accounts/pollingUserAccountSubscriber");
const webSocketUserAccountSubscriber_1 = require("./accounts/webSocketUserAccountSubscriber");
const spotPosition_1 = require("./math/spotPosition");
const oracles_1 = require("./math/oracles");
class User {
    get isSubscribed() {
        return this._isSubscribed && this.accountSubscriber.isSubscribed;
    }
    set isSubscribed(val) {
        this._isSubscribed = val;
    }
    constructor(config) {
        var _a;
        this._isSubscribed = false;
        this.driftClient = config.driftClient;
        this.userAccountPublicKey = config.userAccountPublicKey;
        if (((_a = config.accountSubscription) === null || _a === void 0 ? void 0 : _a.type) === 'polling') {
            this.accountSubscriber = new pollingUserAccountSubscriber_1.PollingUserAccountSubscriber(config.driftClient.program, config.userAccountPublicKey, config.accountSubscription.accountLoader);
        }
        else {
            this.accountSubscriber = new webSocketUserAccountSubscriber_1.WebSocketUserAccountSubscriber(config.driftClient.program, config.userAccountPublicKey);
        }
        this.eventEmitter = this.accountSubscriber.eventEmitter;
    }
    /**
     * Subscribe to User state accounts
     * @returns SusbcriptionSuccess result
     */
    async subscribe(userAccount) {
        this.isSubscribed = await this.accountSubscriber.subscribe(userAccount);
        return this.isSubscribed;
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    async fetchAccounts() {
        await this.accountSubscriber.fetch();
    }
    async unsubscribe() {
        await this.accountSubscriber.unsubscribe();
        this.isSubscribed = false;
    }
    getUserAccount() {
        return this.accountSubscriber.getUserAccountAndSlot().data;
    }
    async forceGetUserAccount() {
        await this.fetchAccounts();
        return this.accountSubscriber.getUserAccountAndSlot().data;
    }
    getUserAccountAndSlot() {
        return this.accountSubscriber.getUserAccountAndSlot();
    }
    /**
     * Gets the user's current position for a given perp market. If the user has no position returns undefined
     * @param marketIndex
     * @returns userPerpPosition
     */
    getPerpPosition(marketIndex) {
        return this.getUserAccount().perpPositions.find((position) => position.marketIndex === marketIndex);
    }
    /**
     * Gets the user's current position for a given spot market. If the user has no position returns undefined
     * @param marketIndex
     * @returns userSpotPosition
     */
    getSpotPosition(marketIndex) {
        return this.getUserAccount().spotPositions.find((position) => position.marketIndex === marketIndex);
    }
    getEmptyPosition(marketIndex) {
        return {
            baseAssetAmount: numericConstants_1.ZERO,
            remainderBaseAssetAmount: 0,
            lastCumulativeFundingRate: numericConstants_1.ZERO,
            marketIndex,
            quoteAssetAmount: numericConstants_1.ZERO,
            quoteEntryAmount: numericConstants_1.ZERO,
            quoteBreakEvenAmount: numericConstants_1.ZERO,
            openOrders: 0,
            openBids: numericConstants_1.ZERO,
            openAsks: numericConstants_1.ZERO,
            settledPnl: numericConstants_1.ZERO,
            lpShares: numericConstants_1.ZERO,
            lastBaseAssetAmountPerLp: numericConstants_1.ZERO,
            lastQuoteAssetAmountPerLp: numericConstants_1.ZERO,
        };
    }
    getClonedPosition(position) {
        const clonedPosition = Object.assign({}, position);
        return clonedPosition;
    }
    /**
     * @param orderId
     * @returns Order
     */
    getOrder(orderId) {
        return this.getUserAccount().orders.find((order) => order.orderId === orderId);
    }
    /**
     * @param userOrderId
     * @returns Order
     */
    getOrderByUserOrderId(userOrderId) {
        return this.getUserAccount().orders.find((order) => order.userOrderId === userOrderId);
    }
    getUserAccountPublicKey() {
        return this.userAccountPublicKey;
    }
    async exists() {
        const userAccountRPCResponse = await this.driftClient.connection.getParsedAccountInfo(this.userAccountPublicKey);
        return userAccountRPCResponse.value !== null;
    }
    /**
     * calculates the total open bids/asks in a perp market (including lps)
     * @returns : open bids
     * @returns : open asks
     */
    getPerpBidAsks(marketIndex) {
        const position = this.getPerpPosition(marketIndex);
        const [lpOpenBids, lpOpenAsks] = this.getLPBidAsks(marketIndex);
        const totalOpenBids = lpOpenBids.add(position.openBids);
        const totalOpenAsks = lpOpenAsks.add(position.openAsks);
        return [totalOpenBids, totalOpenAsks];
    }
    /**
     * calculates the open bids and asks for an lp
     * @returns : lp open bids
     * @returns : lp open asks
     */
    getLPBidAsks(marketIndex) {
        const position = this.getPerpPosition(marketIndex);
        if (position === undefined || position.lpShares.eq(numericConstants_1.ZERO)) {
            return [numericConstants_1.ZERO, numericConstants_1.ZERO];
        }
        const market = this.driftClient.getPerpMarketAccount(marketIndex);
        const [marketOpenBids, marketOpenAsks] = (0, amm_1.calculateMarketOpenBidAsk)(market.amm.baseAssetReserve, market.amm.minBaseAssetReserve, market.amm.maxBaseAssetReserve, market.amm.orderStepSize);
        const lpOpenBids = marketOpenBids
            .mul(position.lpShares)
            .div(market.amm.sqrtK);
        const lpOpenAsks = marketOpenAsks
            .mul(position.lpShares)
            .div(market.amm.sqrtK);
        return [lpOpenBids, lpOpenAsks];
    }
    /**
     * calculates the market position if the lp position was settled
     * @returns : the settled userPosition
     * @returns : the dust base asset amount (ie, < stepsize)
     * @returns : pnl from settle
     */
    getSettledLPPosition(marketIndex) {
        const _position = this.getPerpPosition(marketIndex);
        const position = this.getClonedPosition(_position);
        if (position.lpShares.eq(numericConstants_1.ZERO)) {
            return [position, numericConstants_1.ZERO, numericConstants_1.ZERO];
        }
        const market = this.driftClient.getPerpMarketAccount(position.marketIndex);
        const nShares = position.lpShares;
        const deltaBaa = market.amm.baseAssetAmountPerLp
            .sub(position.lastBaseAssetAmountPerLp)
            .mul(nShares)
            .div(numericConstants_1.AMM_RESERVE_PRECISION);
        const deltaQaa = market.amm.quoteAssetAmountPerLp
            .sub(position.lastQuoteAssetAmountPerLp)
            .mul(nShares)
            .div(numericConstants_1.AMM_RESERVE_PRECISION);
        function sign(v) {
            const sign = { true: new _1.BN(1), false: new _1.BN(-1) }[v.gte(numericConstants_1.ZERO).toString()];
            return sign;
        }
        function standardize(amount, stepsize) {
            const remainder = amount.abs().mod(stepsize).mul(sign(amount));
            const standardizedAmount = amount.sub(remainder);
            return [standardizedAmount, remainder];
        }
        const [standardizedBaa, remainderBaa] = standardize(deltaBaa, market.amm.orderStepSize);
        position.remainderBaseAssetAmount += remainderBaa.toNumber();
        if (Math.abs(position.remainderBaseAssetAmount) >
            market.amm.orderStepSize.toNumber()) {
            const [newStandardizedBaa, newRemainderBaa] = standardize(new _1.BN(position.remainderBaseAssetAmount), market.amm.orderStepSize);
            position.baseAssetAmount =
                position.baseAssetAmount.add(newStandardizedBaa);
            position.remainderBaseAssetAmount = newRemainderBaa.toNumber();
        }
        let updateType;
        if (position.baseAssetAmount.eq(numericConstants_1.ZERO)) {
            updateType = 'open';
        }
        else if (sign(position.baseAssetAmount).eq(sign(deltaBaa))) {
            updateType = 'increase';
        }
        else if (position.baseAssetAmount.abs().gt(deltaBaa.abs())) {
            updateType = 'reduce';
        }
        else if (position.baseAssetAmount.abs().eq(deltaBaa.abs())) {
            updateType = 'close';
        }
        else {
            updateType = 'flip';
        }
        let newQuoteEntry;
        let pnl;
        if (updateType == 'open' || updateType == 'increase') {
            newQuoteEntry = position.quoteEntryAmount.add(deltaQaa);
            pnl = 0;
        }
        else if (updateType == 'reduce' || updateType == 'close') {
            newQuoteEntry = position.quoteEntryAmount.sub(position.quoteEntryAmount
                .mul(deltaBaa.abs())
                .div(position.baseAssetAmount.abs()));
            pnl = position.quoteEntryAmount.sub(newQuoteEntry).add(deltaQaa);
        }
        else {
            newQuoteEntry = deltaQaa.sub(deltaQaa.mul(position.baseAssetAmount.abs()).div(deltaBaa.abs()));
            pnl = position.quoteEntryAmount.add(deltaQaa.sub(newQuoteEntry));
        }
        position.quoteEntryAmount = newQuoteEntry;
        position.baseAssetAmount = position.baseAssetAmount.add(standardizedBaa);
        position.quoteAssetAmount = position.quoteAssetAmount.add(deltaQaa);
        if (position.baseAssetAmount.gt(numericConstants_1.ZERO)) {
            position.lastCumulativeFundingRate = market.amm.cumulativeFundingRateLong;
        }
        else if (position.baseAssetAmount.lt(numericConstants_1.ZERO)) {
            position.lastCumulativeFundingRate =
                market.amm.cumulativeFundingRateShort;
        }
        else {
            position.lastCumulativeFundingRate = numericConstants_1.ZERO;
        }
        return [position, remainderBaa, pnl];
    }
    /**
     * calculates Buying Power = free collateral / initial margin ratio
     * @returns : Precision QUOTE_PRECISION
     */
    getPerpBuyingPower(marketIndex) {
        const perpPosition = this.getPerpPosition(marketIndex);
        const worstCaseBaseAssetAmount = perpPosition
            ? (0, margin_1.calculateWorstCaseBaseAssetAmount)(perpPosition)
            : numericConstants_1.ZERO;
        const freeCollateral = this.getFreeCollateral();
        return this.getPerpBuyingPowerFromFreeCollateralAndBaseAssetAmount(marketIndex, freeCollateral, worstCaseBaseAssetAmount);
    }
    getPerpBuyingPowerFromFreeCollateralAndBaseAssetAmount(marketIndex, freeCollateral, baseAssetAmount) {
        const marginRatio = (0, _1.calculateMarketMarginRatio)(this.driftClient.getPerpMarketAccount(marketIndex), baseAssetAmount, 'Initial');
        return freeCollateral.mul(numericConstants_1.MARGIN_PRECISION).div(new _1.BN(marginRatio));
    }
    /**
     * calculates Free Collateral = Total collateral - initial margin requirement
     * @returns : Precision QUOTE_PRECISION
     */
    getFreeCollateral() {
        const totalCollateral = this.getTotalCollateral();
        const initialMarginRequirement = this.getInitialMarginRequirement();
        const freeCollateral = totalCollateral.sub(initialMarginRequirement);
        return freeCollateral.gte(numericConstants_1.ZERO) ? freeCollateral : numericConstants_1.ZERO;
    }
    /**
     * @returns The margin requirement of a certain type (Initial or Maintenance) in USDC. : QUOTE_PRECISION
     */
    getMarginRequirement(marginCategory, liquidationBuffer, strict = false) {
        return this.getTotalPerpPositionValue(marginCategory, liquidationBuffer, true, strict).add(this.getSpotMarketLiabilityValue(undefined, marginCategory, liquidationBuffer, true, strict));
    }
    /**
     * @returns The initial margin requirement in USDC. : QUOTE_PRECISION
     */
    getInitialMarginRequirement() {
        return this.getMarginRequirement('Initial', undefined, true);
    }
    /**
     * @returns The maintenance margin requirement in USDC. : QUOTE_PRECISION
     */
    getMaintenanceMarginRequirement(liquidationBuffer) {
        return this.getMarginRequirement('Maintenance', liquidationBuffer);
    }
    getActivePerpPositions() {
        return this.getUserAccount().perpPositions.filter((pos) => !pos.baseAssetAmount.eq(numericConstants_1.ZERO) ||
            !pos.quoteAssetAmount.eq(numericConstants_1.ZERO) ||
            !(pos.openOrders == 0) ||
            !pos.lpShares.eq(numericConstants_1.ZERO));
    }
    /**
     * calculates unrealized position price pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getUnrealizedPNL(withFunding, marketIndex, withWeightMarginCategory, strict = false) {
        return this.getActivePerpPositions()
            .filter((pos) => (marketIndex ? pos.marketIndex === marketIndex : true))
            .reduce((unrealizedPnl, perpPosition) => {
            const market = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
            const oraclePriceData = this.getOracleDataForPerpMarket(market.marketIndex);
            const quoteSpotMarket = this.driftClient.getSpotMarketAccount(market.quoteSpotMarketIndex);
            const quoteOraclePriceData = this.getOracleDataForSpotMarket(market.quoteSpotMarketIndex);
            if (perpPosition.lpShares.gt(numericConstants_1.ZERO)) {
                perpPosition = this.getSettledLPPosition(perpPosition.marketIndex)[0];
            }
            let positionUnrealizedPnl = (0, _1.calculatePositionPNL)(market, perpPosition, withFunding, oraclePriceData);
            let quotePrice;
            if (strict && positionUnrealizedPnl.gt(numericConstants_1.ZERO)) {
                quotePrice = _1.BN.min(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
            }
            else if (strict && positionUnrealizedPnl.lt(numericConstants_1.ZERO)) {
                quotePrice = _1.BN.max(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
            }
            else {
                quotePrice = quoteOraclePriceData.price;
            }
            positionUnrealizedPnl = positionUnrealizedPnl
                .mul(quotePrice)
                .div(new _1.BN(numericConstants_1.PRICE_PRECISION));
            if (withWeightMarginCategory !== undefined) {
                if (positionUnrealizedPnl.gt(numericConstants_1.ZERO)) {
                    positionUnrealizedPnl = positionUnrealizedPnl
                        .mul((0, _1.calculateUnrealizedAssetWeight)(market, quoteSpotMarket, positionUnrealizedPnl, withWeightMarginCategory, oraclePriceData))
                        .div(new _1.BN(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION));
                }
            }
            return unrealizedPnl.add(positionUnrealizedPnl);
        }, numericConstants_1.ZERO);
    }
    /**
     * calculates unrealized funding payment pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getUnrealizedFundingPNL(marketIndex) {
        return this.getUserAccount()
            .perpPositions.filter((pos) => marketIndex ? pos.marketIndex === marketIndex : true)
            .reduce((pnl, perpPosition) => {
            const market = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
            return pnl.add((0, _1.calculatePositionFundingPNL)(market, perpPosition));
        }, numericConstants_1.ZERO);
    }
    getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, liquidationBuffer, includeOpenOrders, strict = false, now) {
        now = now || new _1.BN(new Date().getTime() / 1000);
        let netQuoteValue = numericConstants_1.ZERO;
        let totalAssetValue = numericConstants_1.ZERO;
        let totalLiabilityValue = numericConstants_1.ZERO;
        for (const spotPosition of this.getUserAccount().spotPositions) {
            const countForBase = marketIndex === undefined || spotPosition.marketIndex === marketIndex;
            const countForQuote = marketIndex === undefined ||
                marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX ||
                (includeOpenOrders && spotPosition.openOrders !== 0);
            if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition) ||
                (!countForBase && !countForQuote)) {
                continue;
            }
            const spotMarketAccount = this.driftClient.getSpotMarketAccount(spotPosition.marketIndex);
            const oraclePriceData = this.getOracleDataForSpotMarket(spotPosition.marketIndex);
            if (spotPosition.marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX &&
                countForQuote) {
                const tokenAmount = (0, _1.getSignedTokenAmount)((0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarketAccount, spotPosition.balanceType), spotPosition.balanceType);
                if ((0, types_1.isVariant)(spotPosition.balanceType, 'borrow')) {
                    const weightedTokenValue = this.getSpotLiabilityValue(tokenAmount, oraclePriceData, spotMarketAccount, marginCategory, liquidationBuffer, strict, now).abs();
                    netQuoteValue = netQuoteValue.sub(weightedTokenValue);
                }
                else {
                    const weightedTokenValue = this.getSpotAssetValue(tokenAmount, oraclePriceData, spotMarketAccount, marginCategory, strict, now);
                    netQuoteValue = netQuoteValue.add(weightedTokenValue);
                }
                continue;
            }
            if (!includeOpenOrders && countForBase) {
                if ((0, types_1.isVariant)(spotPosition.balanceType, 'borrow')) {
                    const tokenAmount = (0, _1.getSignedTokenAmount)((0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarketAccount, spotPosition.balanceType), _1.SpotBalanceType.BORROW);
                    const liabilityValue = this.getSpotLiabilityValue(tokenAmount, oraclePriceData, spotMarketAccount, marginCategory, liquidationBuffer, strict, now).abs();
                    totalLiabilityValue = totalLiabilityValue.add(liabilityValue);
                    continue;
                }
                else {
                    const tokenAmount = (0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarketAccount, spotPosition.balanceType);
                    const assetValue = this.getSpotAssetValue(tokenAmount, oraclePriceData, spotMarketAccount, marginCategory, strict, now);
                    totalAssetValue = totalAssetValue.add(assetValue);
                    continue;
                }
            }
            const [worstCaseTokenAmount, worstCaseQuoteTokenAmount] = (0, spotPosition_1.getWorstCaseTokenAmounts)(spotPosition, spotMarketAccount, this.getOracleDataForSpotMarket(spotPosition.marketIndex));
            if (worstCaseTokenAmount.gt(numericConstants_1.ZERO) && countForBase) {
                const baseAssetValue = this.getSpotAssetValue(worstCaseTokenAmount, oraclePriceData, spotMarketAccount, marginCategory, strict, now);
                totalAssetValue = totalAssetValue.add(baseAssetValue);
            }
            if (worstCaseTokenAmount.lt(numericConstants_1.ZERO) && countForBase) {
                const baseLiabilityValue = this.getSpotLiabilityValue(worstCaseTokenAmount, oraclePriceData, spotMarketAccount, marginCategory, liquidationBuffer, strict, now).abs();
                totalLiabilityValue = totalLiabilityValue.add(baseLiabilityValue);
            }
            if (worstCaseQuoteTokenAmount.gt(numericConstants_1.ZERO) && countForQuote) {
                netQuoteValue = netQuoteValue.add(worstCaseQuoteTokenAmount);
            }
            if (worstCaseQuoteTokenAmount.lt(numericConstants_1.ZERO) && countForQuote) {
                let weight = numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION;
                if (marginCategory === 'Initial') {
                    weight = _1.BN.max(weight, new _1.BN(this.getUserAccount().maxMarginRatio));
                }
                const weightedTokenValue = worstCaseQuoteTokenAmount
                    .abs()
                    .mul(weight)
                    .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION);
                netQuoteValue = netQuoteValue.sub(weightedTokenValue);
            }
            totalLiabilityValue = totalLiabilityValue.add(new _1.BN(spotPosition.openOrders).mul(numericConstants_1.OPEN_ORDER_MARGIN_REQUIREMENT));
        }
        if (marketIndex === undefined || marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX) {
            if (netQuoteValue.gt(numericConstants_1.ZERO)) {
                totalAssetValue = totalAssetValue.add(netQuoteValue);
            }
            else {
                totalLiabilityValue = totalLiabilityValue.add(netQuoteValue.abs());
            }
        }
        return { totalAssetValue, totalLiabilityValue };
    }
    getSpotMarketLiabilityValue(marketIndex, marginCategory, liquidationBuffer, includeOpenOrders, strict = false, now) {
        const { totalLiabilityValue } = this.getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, liquidationBuffer, includeOpenOrders, strict, now);
        return totalLiabilityValue;
    }
    getSpotLiabilityValue(tokenAmount, oraclePriceData, spotMarketAccount, marginCategory, liquidationBuffer, strict = false, now) {
        let liabilityValue = null;
        if (strict) {
            const estOracleTwap = (0, oracles_1.calculateLiveOracleTwap)(spotMarketAccount.historicalOracleData, oraclePriceData, now, numericConstants_1.FIVE_MINUTE // 5MIN
            );
            liabilityValue = (0, _1.getStrictTokenValue)(tokenAmount, spotMarketAccount.decimals, oraclePriceData, estOracleTwap);
        }
        else {
            liabilityValue = (0, _1.getTokenValue)(tokenAmount, spotMarketAccount.decimals, oraclePriceData);
        }
        if (marginCategory !== undefined) {
            let weight = (0, spotBalance_1.calculateLiabilityWeight)(tokenAmount, spotMarketAccount, marginCategory);
            if (marginCategory === 'Initial') {
                weight = _1.BN.max(weight, new _1.BN(this.getUserAccount().maxMarginRatio));
            }
            if (liquidationBuffer !== undefined) {
                weight = weight.add(liquidationBuffer);
            }
            liabilityValue = liabilityValue
                .mul(weight)
                .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION);
        }
        return liabilityValue;
    }
    getSpotMarketAssetValue(marketIndex, marginCategory, includeOpenOrders, strict = false, now) {
        const { totalAssetValue } = this.getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, undefined, includeOpenOrders, strict, now);
        return totalAssetValue;
    }
    getSpotAssetValue(tokenAmount, oraclePriceData, spotMarketAccount, marginCategory, strict = false, now) {
        let assetValue = null;
        if (strict) {
            const estOracleTwap = (0, oracles_1.calculateLiveOracleTwap)(spotMarketAccount.historicalOracleData, oraclePriceData, now, numericConstants_1.FIVE_MINUTE // 5MIN
            );
            assetValue = (0, _1.getStrictTokenValue)(tokenAmount, spotMarketAccount.decimals, oraclePriceData, estOracleTwap);
        }
        else {
            assetValue = (0, _1.getTokenValue)(tokenAmount, spotMarketAccount.decimals, oraclePriceData);
        }
        if (marginCategory !== undefined) {
            const weight = (0, spotBalance_1.calculateAssetWeight)(tokenAmount, spotMarketAccount, marginCategory);
            assetValue = assetValue.mul(weight).div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION);
        }
        return assetValue;
    }
    getSpotTokenAmount(marketIndex) {
        const spotPosition = this.getSpotPosition(marketIndex);
        return (0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, this.driftClient.getSpotMarketAccount(marketIndex), spotPosition.balanceType);
    }
    getSpotPositionValue(marketIndex, marginCategory, includeOpenOrders, strict = false, now) {
        const { totalAssetValue, totalLiabilityValue } = this.getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, undefined, includeOpenOrders, strict, now);
        return totalAssetValue.sub(totalLiabilityValue);
    }
    getNetSpotMarketValue(withWeightMarginCategory) {
        const { totalAssetValue, totalLiabilityValue } = this.getSpotMarketAssetAndLiabilityValue(undefined, withWeightMarginCategory);
        return totalAssetValue.sub(totalLiabilityValue);
    }
    /**
     * calculates TotalCollateral: collateral + unrealized pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getTotalCollateral(marginCategory = 'Initial', strict = false) {
        return this.getSpotMarketAssetValue(undefined, marginCategory, true, strict).add(this.getUnrealizedPNL(true, undefined, marginCategory, strict));
    }
    /**
     * calculates User Health by comparing total collateral and maint. margin requirement
     * @returns : number (value from [0, 100])
     */
    getHealth() {
        const userAccount = this.getUserAccount();
        if ((0, types_1.isVariant)(userAccount.status, 'beingLiquidated') ||
            (0, types_1.isVariant)(userAccount.status, 'bankrupt')) {
            return 0;
        }
        const totalCollateral = this.getTotalCollateral('Maintenance');
        const maintenanceMarginReq = this.getMaintenanceMarginRequirement();
        let health;
        if (maintenanceMarginReq.eq(numericConstants_1.ZERO) && totalCollateral.gte(numericConstants_1.ZERO)) {
            health = 100;
        }
        else if (totalCollateral.lte(numericConstants_1.ZERO)) {
            health = 0;
        }
        else {
            const healthP1 = Math.max(0, (1 - maintenanceMarginReq.toNumber() / totalCollateral.toNumber()) *
                100) + 1;
            health = Math.min(1, Math.log(healthP1) / Math.log(100)) * 100;
            if (health > 1) {
                health = Math.round(health);
            }
            else {
                health = Math.round(health * 100) / 100;
            }
        }
        return health;
    }
    /**
     * calculates sum of position value across all positions in margin system
     * @returns : Precision QUOTE_PRECISION
     */
    getTotalPerpPositionValue(marginCategory, liquidationBuffer, includeOpenOrders, strict = false) {
        return this.getActivePerpPositions().reduce((totalPerpValue, perpPosition) => {
            const market = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
            if (perpPosition.lpShares.gt(numericConstants_1.ZERO)) {
                // is an lp
                // clone so we dont mutate the position
                perpPosition = this.getClonedPosition(perpPosition);
                // settle position
                const [settledPosition, dustBaa, _] = this.getSettledLPPosition(market.marketIndex);
                perpPosition.baseAssetAmount =
                    settledPosition.baseAssetAmount.add(dustBaa);
                perpPosition.quoteAssetAmount = settledPosition.quoteAssetAmount;
                const [totalOpenBids, totalOpenAsks] = this.getPerpBidAsks(market.marketIndex);
                perpPosition.openAsks = totalOpenAsks;
                perpPosition.openBids = totalOpenBids;
            }
            let valuationPrice = this.getOracleDataForPerpMarket(market.marketIndex).price;
            if ((0, types_1.isVariant)(market.status, 'settlement')) {
                valuationPrice = market.expiryPrice;
            }
            const baseAssetAmount = includeOpenOrders
                ? (0, margin_1.calculateWorstCaseBaseAssetAmount)(perpPosition)
                : perpPosition.baseAssetAmount;
            let baseAssetValue = baseAssetAmount
                .abs()
                .mul(valuationPrice)
                .div(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO.mul(numericConstants_1.PRICE_PRECISION));
            if (marginCategory) {
                let marginRatio = new _1.BN((0, _1.calculateMarketMarginRatio)(market, baseAssetAmount.abs(), marginCategory));
                if (marginCategory === 'Initial') {
                    marginRatio = _1.BN.max(marginRatio, new _1.BN(this.getUserAccount().maxMarginRatio));
                }
                if (liquidationBuffer !== undefined) {
                    marginRatio = marginRatio.add(liquidationBuffer);
                }
                if ((0, types_1.isVariant)(market.status, 'settlement')) {
                    marginRatio = numericConstants_1.ZERO;
                }
                const quoteSpotMarket = this.driftClient.getSpotMarketAccount(market.quoteSpotMarketIndex);
                const quoteOraclePriceData = this.driftClient.getOraclePriceDataAndSlot(quoteSpotMarket.oracle).data;
                let quotePrice;
                if (strict) {
                    quotePrice = _1.BN.max(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
                }
                else {
                    quotePrice = quoteOraclePriceData.price;
                }
                baseAssetValue = baseAssetValue
                    .mul(quotePrice)
                    .div(numericConstants_1.PRICE_PRECISION)
                    .mul(marginRatio)
                    .div(numericConstants_1.MARGIN_PRECISION);
                if (includeOpenOrders) {
                    baseAssetValue = baseAssetValue.add(new _1.BN(perpPosition.openOrders).mul(numericConstants_1.OPEN_ORDER_MARGIN_REQUIREMENT));
                }
            }
            return totalPerpValue.add(baseAssetValue);
        }, numericConstants_1.ZERO);
    }
    /**
     * calculates position value in margin system
     * @returns : Precision QUOTE_PRECISION
     */
    getPerpPositionValue(marketIndex, oraclePriceData, includeOpenOrders = false) {
        const userPosition = this.getPerpPosition(marketIndex) || this.getEmptyPosition(marketIndex);
        const market = this.driftClient.getPerpMarketAccount(userPosition.marketIndex);
        return (0, margin_1.calculateBaseAssetValueWithOracle)(market, userPosition, oraclePriceData, includeOpenOrders);
    }
    getPositionSide(currentPosition) {
        if (currentPosition.baseAssetAmount.gt(numericConstants_1.ZERO)) {
            return _1.PositionDirection.LONG;
        }
        else if (currentPosition.baseAssetAmount.lt(numericConstants_1.ZERO)) {
            return _1.PositionDirection.SHORT;
        }
        else {
            return undefined;
        }
    }
    /**
     * calculates average exit price (optionally for closing up to 100% of position)
     * @returns : Precision PRICE_PRECISION
     */
    getPositionEstimatedExitPriceAndPnl(position, amountToClose, useAMMClose = false) {
        const market = this.driftClient.getPerpMarketAccount(position.marketIndex);
        const entryPrice = (0, position_1.calculateEntryPrice)(position);
        const oraclePriceData = this.getOracleDataForPerpMarket(position.marketIndex);
        if (amountToClose) {
            if (amountToClose.eq(numericConstants_1.ZERO)) {
                return [(0, _1.calculateReservePrice)(market, oraclePriceData), numericConstants_1.ZERO];
            }
            position = {
                baseAssetAmount: amountToClose,
                lastCumulativeFundingRate: position.lastCumulativeFundingRate,
                marketIndex: position.marketIndex,
                quoteAssetAmount: position.quoteAssetAmount,
            };
        }
        let baseAssetValue;
        if (useAMMClose) {
            baseAssetValue = (0, _1.calculateBaseAssetValue)(market, position, oraclePriceData);
        }
        else {
            baseAssetValue = (0, margin_1.calculateBaseAssetValueWithOracle)(market, position, oraclePriceData);
        }
        if (position.baseAssetAmount.eq(numericConstants_1.ZERO)) {
            return [numericConstants_1.ZERO, numericConstants_1.ZERO];
        }
        const exitPrice = baseAssetValue
            .mul(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO)
            .mul(numericConstants_1.PRICE_PRECISION)
            .div(position.baseAssetAmount.abs());
        const pnlPerBase = exitPrice.sub(entryPrice);
        const pnl = pnlPerBase
            .mul(position.baseAssetAmount)
            .div(numericConstants_1.PRICE_PRECISION)
            .div(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO);
        return [exitPrice, pnl];
    }
    /**
     * calculates current user leverage which is (total liability size) / (net asset value)
     * @returns : Precision TEN_THOUSAND
     */
    getLeverage() {
        // get leverage components
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const totalAssetValue = spotAssetValue.add(perpPnl);
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        return totalLiabilityValue.mul(numericConstants_1.TEN_THOUSAND).div(netAssetValue);
    }
    getLeverageComponents() {
        const perpLiability = this.getTotalPerpPositionValue(undefined, undefined, true);
        const perpPnl = this.getUnrealizedPNL(true);
        const { totalAssetValue: spotAssetValue, totalLiabilityValue: spotLiabilityValue, } = this.getSpotMarketAssetAndLiabilityValue(undefined, undefined, undefined, true);
        return {
            perpLiabilityValue: perpLiability,
            perpPnl,
            spotAssetValue,
            spotLiabilityValue,
        };
    }
    getTotalLiabilityValue(marginCategory) {
        return this.getTotalPerpPositionValue(marginCategory, undefined, true).add(this.getSpotMarketLiabilityValue(undefined, marginCategory, undefined, true));
    }
    getTotalAssetValue(marginCategory) {
        return this.getSpotMarketAssetValue(undefined, marginCategory, true).add(this.getUnrealizedPNL(true, undefined, marginCategory));
    }
    /**
     * calculates max allowable leverage exceeding hitting requirement category
     * @params category {Initial, Maintenance}
     * @returns : Precision TEN_THOUSAND
     */
    getMaxLeverageForPerp(perpMarketIndex, category = 'Initial') {
        const market = this.driftClient.getPerpMarketAccount(perpMarketIndex);
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const totalAssetValue = spotAssetValue.add(perpPnl);
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const marginRatio = (0, _1.calculateMarketMarginRatio)(market, numericConstants_1.ZERO, // todo
        category);
        const freeCollateral = this.getFreeCollateral();
        // how much more liabilities can be opened w remaining free collateral
        const additionalLiabilities = freeCollateral
            .mul(numericConstants_1.MARGIN_PRECISION)
            .div(new _1.BN(marginRatio));
        return totalLiabilityValue
            .add(additionalLiabilities)
            .mul(numericConstants_1.TEN_THOUSAND)
            .div(netAssetValue);
    }
    /**
     * calculates max allowable leverage exceeding hitting requirement category
     * @param spotMarketIndex
     * @param direction
     * @returns : Precision TEN_THOUSAND
     */
    getMaxLeverageForSpot(spotMarketIndex, direction) {
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const totalAssetValue = spotAssetValue.add(perpPnl);
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        const currentQuoteAssetValue = this.getSpotMarketAssetValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const currentQuoteLiabilityValue = this.getSpotMarketLiabilityValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const currentQuoteValue = currentQuoteAssetValue.sub(currentQuoteLiabilityValue);
        const currentSpotMarketAssetValue = this.getSpotMarketAssetValue(spotMarketIndex);
        const currentSpotMarketLiabilityValue = this.getSpotMarketLiabilityValue(spotMarketIndex);
        const currentSpotMarketNetValue = currentSpotMarketAssetValue.sub(currentSpotMarketLiabilityValue);
        const tradeQuoteAmount = this.getMaxTradeSizeUSDCForSpot(spotMarketIndex, direction, currentQuoteAssetValue, currentSpotMarketNetValue);
        let assetValueToAdd = numericConstants_1.ZERO;
        let liabilityValueToAdd = numericConstants_1.ZERO;
        const newQuoteNetValue = (0, types_1.isVariant)(direction, 'short')
            ? currentQuoteValue.add(tradeQuoteAmount)
            : currentQuoteValue.sub(tradeQuoteAmount);
        const newQuoteAssetValue = _1.BN.max(newQuoteNetValue, numericConstants_1.ZERO);
        const newQuoteLiabilityValue = _1.BN.min(newQuoteNetValue, numericConstants_1.ZERO).abs();
        assetValueToAdd = assetValueToAdd.add(newQuoteAssetValue.sub(currentQuoteAssetValue));
        liabilityValueToAdd = liabilityValueToAdd.add(newQuoteLiabilityValue.sub(currentQuoteLiabilityValue));
        const newSpotMarketNetValue = (0, types_1.isVariant)(direction, 'long')
            ? currentSpotMarketNetValue.add(tradeQuoteAmount)
            : currentSpotMarketNetValue.sub(tradeQuoteAmount);
        const newSpotMarketAssetValue = _1.BN.max(newSpotMarketNetValue, numericConstants_1.ZERO);
        const newSpotMarketLiabilityValue = _1.BN.min(newSpotMarketNetValue, numericConstants_1.ZERO).abs();
        assetValueToAdd = assetValueToAdd.add(newSpotMarketAssetValue.sub(currentSpotMarketAssetValue));
        liabilityValueToAdd = liabilityValueToAdd.add(newSpotMarketLiabilityValue.sub(currentSpotMarketLiabilityValue));
        const finalTotalAssetValue = totalAssetValue.add(assetValueToAdd);
        const finalTotalSpotLiability = spotLiabilityValue.add(liabilityValueToAdd);
        const finalTotalLiabilityValue = totalLiabilityValue.add(liabilityValueToAdd);
        const finalNetAssetValue = finalTotalAssetValue.sub(finalTotalSpotLiability);
        return finalTotalLiabilityValue.mul(numericConstants_1.TEN_THOUSAND).div(finalNetAssetValue);
    }
    /**
     * calculates margin ratio: 1 / leverage
     * @returns : Precision TEN_THOUSAND
     */
    getMarginRatio() {
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const totalAssetValue = spotAssetValue.add(perpPnl);
        if (totalLiabilityValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.BN_MAX;
        }
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        return netAssetValue.mul(numericConstants_1.TEN_THOUSAND).div(totalLiabilityValue);
    }
    canBeLiquidated() {
        const totalCollateral = this.getTotalCollateral('Maintenance');
        // if user being liq'd, can continue to be liq'd until total collateral above the margin requirement plus buffer
        let liquidationBuffer = undefined;
        const isBeingLiquidated = (0, types_1.isVariant)(this.getUserAccount().status, 'beingLiquidated');
        if (isBeingLiquidated) {
            liquidationBuffer = new _1.BN(this.driftClient.getStateAccount().liquidationMarginBufferRatio);
        }
        const maintenanceRequirement = this.getMaintenanceMarginRequirement(liquidationBuffer);
        return totalCollateral.lt(maintenanceRequirement);
    }
    isBeingLiquidated() {
        return (0, types_1.isOneOfVariant)(this.getUserAccount().status, [
            'beingLiquidated',
            'bankrupt',
        ]);
    }
    isBankrupt() {
        return (0, types_1.isVariant)(this.getUserAccount().status, 'bankrupt');
    }
    /**
     * Checks if any user position cumulative funding differs from respective market cumulative funding
     * @returns
     */
    needsToSettleFundingPayment() {
        for (const userPosition of this.getUserAccount().perpPositions) {
            if (userPosition.baseAssetAmount.eq(numericConstants_1.ZERO)) {
                continue;
            }
            const market = this.driftClient.getPerpMarketAccount(userPosition.marketIndex);
            if (market.amm.cumulativeFundingRateLong.eq(userPosition.lastCumulativeFundingRate) ||
                market.amm.cumulativeFundingRateShort.eq(userPosition.lastCumulativeFundingRate)) {
                continue;
            }
            return true;
        }
        return false;
    }
    /**
     * Calculate the liquidation price of a spot position
     * @param marketIndex
     * @returns Precision : PRICE_PRECISION
     */
    spotLiquidationPrice(marketIndex, positionBaseSizeChange = numericConstants_1.ZERO) {
        const currentSpotPosition = this.getSpotPosition(marketIndex);
        if (!currentSpotPosition) {
            return new _1.BN(-1);
        }
        const totalCollateral = this.getTotalCollateral('Maintenance');
        const maintenanceMarginRequirement = this.getMaintenanceMarginRequirement();
        const freeCollateral = _1.BN.max(numericConstants_1.ZERO, totalCollateral.sub(maintenanceMarginRequirement));
        const market = this.driftClient.getSpotMarketAccount(marketIndex);
        let signedTokenAmount = (0, _1.getSignedTokenAmount)((0, spotBalance_1.getTokenAmount)(currentSpotPosition.scaledBalance, market, currentSpotPosition.balanceType), currentSpotPosition.balanceType);
        signedTokenAmount = signedTokenAmount.add(positionBaseSizeChange);
        if (signedTokenAmount.eq(numericConstants_1.ZERO)) {
            return new _1.BN(-1);
        }
        let freeCollateralDelta = this.calculateFreeCollateralDeltaForSpot(market, signedTokenAmount);
        const oracle = market.oracle;
        const perpMarketWithSameOracle = this.driftClient
            .getPerpMarketAccounts()
            .find((market) => market.amm.oracle.equals(oracle));
        if (perpMarketWithSameOracle) {
            const perpPosition = this.getPerpPosition(perpMarketWithSameOracle.marketIndex);
            if (perpPosition) {
                const freeCollateralDeltaForPerp = this.calculateFreeCollateralDeltaForPerp(perpMarketWithSameOracle, perpPosition, numericConstants_1.ZERO);
                freeCollateralDelta = freeCollateralDelta.add(freeCollateralDeltaForPerp || numericConstants_1.ZERO);
            }
        }
        if (freeCollateralDelta.eq(numericConstants_1.ZERO)) {
            return new _1.BN(-1);
        }
        const oraclePrice = this.driftClient.getOracleDataForSpotMarket(marketIndex).price;
        const liqPriceDelta = freeCollateral
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(freeCollateralDelta);
        const liqPrice = oraclePrice.sub(liqPriceDelta);
        if (liqPrice.lt(numericConstants_1.ZERO)) {
            return new _1.BN(-1);
        }
        return liqPrice;
    }
    /**
     * Calculate the liquidation price of a perp position, with optional parameter to calculate the liquidation price after a trade
     * @param marketIndex
     * @param positionBaseSizeChange // change in position size to calculate liquidation price for : Precision 10^13
     * @returns Precision : PRICE_PRECISION
     */
    liquidationPrice(marketIndex, positionBaseSizeChange = numericConstants_1.ZERO) {
        const totalCollateral = this.getTotalCollateral('Maintenance');
        const maintenanceMarginRequirement = this.getMaintenanceMarginRequirement();
        const freeCollateral = _1.BN.max(numericConstants_1.ZERO, totalCollateral.sub(maintenanceMarginRequirement));
        const market = this.driftClient.getPerpMarketAccount(marketIndex);
        const currentPerpPosition = this.getPerpPosition(marketIndex) || this.getEmptyPosition(marketIndex);
        let freeCollateralDelta = this.calculateFreeCollateralDeltaForPerp(market, currentPerpPosition, positionBaseSizeChange);
        if (!freeCollateralDelta) {
            return new _1.BN(-1);
        }
        const oracle = this.driftClient.getPerpMarketAccount(marketIndex).amm.oracle;
        const spotMarketWithSameOracle = this.driftClient
            .getSpotMarketAccounts()
            .find((market) => market.oracle.equals(oracle));
        if (spotMarketWithSameOracle) {
            const spotPosition = this.getSpotPosition(spotMarketWithSameOracle.marketIndex);
            if (spotPosition) {
                const signedTokenAmount = (0, _1.getSignedTokenAmount)((0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarketWithSameOracle, spotPosition.balanceType), spotPosition.balanceType);
                const spotFreeCollateralDelta = this.calculateFreeCollateralDeltaForSpot(spotMarketWithSameOracle, signedTokenAmount);
                freeCollateralDelta = freeCollateralDelta.add(spotFreeCollateralDelta || numericConstants_1.ZERO);
            }
        }
        if (freeCollateralDelta.eq(numericConstants_1.ZERO)) {
            return new _1.BN(-1);
        }
        const oraclePrice = this.driftClient.getOracleDataForPerpMarket(marketIndex).price;
        const liqPriceDelta = freeCollateral
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(freeCollateralDelta);
        const liqPrice = oraclePrice.sub(liqPriceDelta);
        if (liqPrice.lt(numericConstants_1.ZERO)) {
            return new _1.BN(-1);
        }
        return liqPrice;
    }
    calculateFreeCollateralDeltaForPerp(market, perpPosition, positionBaseSizeChange) {
        const currentBaseAssetAmount = perpPosition.baseAssetAmount;
        const worstCaseBaseAssetAmount = (0, margin_1.calculateWorstCaseBaseAssetAmount)(perpPosition);
        const orderBaseAssetAmount = worstCaseBaseAssetAmount.sub(currentBaseAssetAmount);
        const proposedBaseAssetAmount = currentBaseAssetAmount.add(positionBaseSizeChange);
        const proposedWorstCaseBaseAssetAmount = worstCaseBaseAssetAmount.add(positionBaseSizeChange);
        const marginRatio = (0, _1.calculateMarketMarginRatio)(market, proposedWorstCaseBaseAssetAmount.abs(), 'Maintenance');
        const marginRatioQuotePrecision = new _1.BN(marginRatio)
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(numericConstants_1.MARGIN_PRECISION);
        if (proposedWorstCaseBaseAssetAmount.eq(numericConstants_1.ZERO)) {
            return undefined;
        }
        let freeCollateralDelta = numericConstants_1.ZERO;
        if (proposedBaseAssetAmount.gt(numericConstants_1.ZERO)) {
            freeCollateralDelta = numericConstants_1.QUOTE_PRECISION.sub(marginRatioQuotePrecision)
                .mul(proposedBaseAssetAmount)
                .div(numericConstants_1.BASE_PRECISION);
        }
        else {
            freeCollateralDelta = numericConstants_1.QUOTE_PRECISION.neg()
                .sub(marginRatioQuotePrecision)
                .mul(proposedBaseAssetAmount.abs())
                .div(numericConstants_1.BASE_PRECISION);
        }
        if (!orderBaseAssetAmount.eq(numericConstants_1.ZERO)) {
            freeCollateralDelta = freeCollateralDelta.sub(marginRatioQuotePrecision);
        }
        return freeCollateralDelta;
    }
    calculateFreeCollateralDeltaForSpot(market, signedTokenAmount) {
        const tokenPrecision = new _1.BN(Math.pow(10, market.decimals));
        if (signedTokenAmount.gt(numericConstants_1.ZERO)) {
            const assetWeight = (0, spotBalance_1.calculateAssetWeight)(signedTokenAmount, market, 'Maintenance');
            return numericConstants_1.QUOTE_PRECISION.mul(assetWeight)
                .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION)
                .mul(signedTokenAmount)
                .div(tokenPrecision);
        }
        else {
            const liabilityWeight = (0, spotBalance_1.calculateLiabilityWeight)(signedTokenAmount.abs(), market, 'Maintenance');
            return numericConstants_1.QUOTE_PRECISION.neg()
                .mul(liabilityWeight)
                .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION)
                .mul(signedTokenAmount.abs())
                .div(tokenPrecision);
        }
    }
    /**
     * Calculates the estimated liquidation price for a position after closing a quote amount of the position.
     * @param positionMarketIndex
     * @param closeQuoteAmount
     * @returns : Precision PRICE_PRECISION
     */
    liquidationPriceAfterClose(positionMarketIndex, closeQuoteAmount) {
        const currentPosition = this.getPerpPosition(positionMarketIndex) ||
            this.getEmptyPosition(positionMarketIndex);
        const closeBaseAmount = currentPosition.baseAssetAmount
            .mul(closeQuoteAmount)
            .div(currentPosition.quoteAssetAmount.abs())
            .add(currentPosition.baseAssetAmount
            .mul(closeQuoteAmount)
            .mod(currentPosition.quoteAssetAmount.abs()))
            .neg();
        return this.liquidationPrice(positionMarketIndex, closeBaseAmount);
    }
    /**
     * Get the maximum trade size for a given market, taking into account the user's current leverage, positions, collateral, etc.
     *
     * To Calculate Max Quote Available:
     *
     * Case 1: SameSide
     * 	=> Remaining quote to get to maxLeverage
     *
     * Case 2: NOT SameSide && currentLeverage <= maxLeverage
     * 	=> Current opposite position x2 + remaining to get to maxLeverage
     *
     * Case 3: NOT SameSide && currentLeverage > maxLeverage && otherPositions - currentPosition > maxLeverage
     * 	=> strictly reduce current position size
     *
     * Case 4: NOT SameSide && currentLeverage > maxLeverage && otherPositions - currentPosition < maxLeverage
     * 	=> current position + remaining to get to maxLeverage
     *
     * @param targetMarketIndex
     * @param tradeSide
     * @returns tradeSizeAllowed : Precision QUOTE_PRECISION
     */
    getMaxTradeSizeUSDCForPerp(targetMarketIndex, tradeSide) {
        const currentPosition = this.getPerpPosition(targetMarketIndex) ||
            this.getEmptyPosition(targetMarketIndex);
        const targetSide = (0, types_1.isVariant)(tradeSide, 'short') ? 'short' : 'long';
        const currentPositionSide = (currentPosition === null || currentPosition === void 0 ? void 0 : currentPosition.baseAssetAmount.isNeg())
            ? 'short'
            : 'long';
        const targetingSameSide = !currentPosition
            ? true
            : targetSide === currentPositionSide;
        const oracleData = this.getOracleDataForPerpMarket(targetMarketIndex);
        // add any position we have on the opposite side of the current trade, because we can "flip" the size of this position without taking any extra leverage.
        const oppositeSizeValueUSDC = targetingSameSide
            ? numericConstants_1.ZERO
            : this.getPerpPositionValue(targetMarketIndex, oracleData);
        let maxPositionSize = this.getPerpBuyingPower(targetMarketIndex);
        if (maxPositionSize.gte(numericConstants_1.ZERO)) {
            if (oppositeSizeValueUSDC.eq(numericConstants_1.ZERO)) {
                // case 1 : Regular trade where current total position less than max, and no opposite position to account for
                // do nothing
            }
            else {
                // case 2 : trade where current total position less than max, but need to account for flipping the current position over to the other side
                maxPositionSize = maxPositionSize.add(oppositeSizeValueUSDC.mul(new _1.BN(2)));
            }
        }
        else {
            // current leverage is greater than max leverage - can only reduce position size
            if (!targetingSameSide) {
                const market = this.driftClient.getPerpMarketAccount(targetMarketIndex);
                const perpPositionValue = this.getPerpPositionValue(targetMarketIndex, oracleData);
                const totalCollateral = this.getTotalCollateral();
                const marginRequirement = this.getInitialMarginRequirement();
                const marginFreedByClosing = perpPositionValue
                    .mul(new _1.BN(market.marginRatioInitial))
                    .div(numericConstants_1.MARGIN_PRECISION);
                const marginRequirementAfterClosing = marginRequirement.sub(marginFreedByClosing);
                if (marginRequirementAfterClosing.gt(totalCollateral)) {
                    maxPositionSize = perpPositionValue;
                }
                else {
                    const freeCollateralAfterClose = totalCollateral.sub(marginRequirementAfterClosing);
                    const buyingPowerAfterClose = this.getPerpBuyingPowerFromFreeCollateralAndBaseAssetAmount(targetMarketIndex, freeCollateralAfterClose, numericConstants_1.ZERO);
                    maxPositionSize = perpPositionValue.add(buyingPowerAfterClose);
                }
            }
            else {
                // do nothing if targetting same side
            }
        }
        return maxPositionSize;
    }
    /**
     * Get the maximum trade size for a given market, taking into account the user's current leverage, positions, collateral, etc.
     *
     * @param targetMarketIndex
     * @param direction
     * @param currentQuoteAssetValue
     * @param currentSpotMarketNetValue
     * @returns tradeSizeAllowed : Precision QUOTE_PRECISION
     */
    getMaxTradeSizeUSDCForSpot(targetMarketIndex, direction, currentQuoteAssetValue, currentSpotMarketNetValue) {
        const market = this.driftClient.getSpotMarketAccount(targetMarketIndex);
        currentQuoteAssetValue = this.getSpotMarketAssetValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        currentSpotMarketNetValue =
            currentSpotMarketNetValue !== null && currentSpotMarketNetValue !== void 0 ? currentSpotMarketNetValue : this.getSpotPositionValue(targetMarketIndex);
        let freeCollateral = this.getFreeCollateral();
        const marginRatio = (0, _1.calculateSpotMarketMarginRatio)(market, 'Initial', numericConstants_1.ZERO, (0, types_1.isVariant)(direction, 'long')
            ? _1.SpotBalanceType.DEPOSIT
            : _1.SpotBalanceType.BORROW);
        let tradeAmount = numericConstants_1.ZERO;
        if (this.getUserAccount().isMarginTradingEnabled) {
            // if the user is buying/selling and already short/long, need to account for closing out short/long
            if ((0, types_1.isVariant)(direction, 'long') && currentSpotMarketNetValue.lt(numericConstants_1.ZERO)) {
                tradeAmount = currentSpotMarketNetValue.abs();
                const marginRatio = (0, _1.calculateSpotMarketMarginRatio)(market, 'Initial', this.getSpotTokenAmount(targetMarketIndex), _1.SpotBalanceType.BORROW);
                freeCollateral = freeCollateral.add(tradeAmount.mul(new _1.BN(marginRatio)).div(numericConstants_1.MARGIN_PRECISION));
            }
            else if ((0, types_1.isVariant)(direction, 'short') &&
                currentSpotMarketNetValue.gt(numericConstants_1.ZERO)) {
                tradeAmount = currentSpotMarketNetValue;
                const marginRatio = (0, _1.calculateSpotMarketMarginRatio)(market, 'Initial', this.getSpotTokenAmount(targetMarketIndex), _1.SpotBalanceType.DEPOSIT);
                freeCollateral = freeCollateral.add(tradeAmount.mul(new _1.BN(marginRatio)).div(numericConstants_1.MARGIN_PRECISION));
            }
            tradeAmount = tradeAmount.add(freeCollateral.mul(numericConstants_1.MARGIN_PRECISION).div(new _1.BN(marginRatio)));
        }
        else if ((0, types_1.isVariant)(direction, 'long')) {
            tradeAmount = _1.BN.min(currentQuoteAssetValue, freeCollateral.mul(numericConstants_1.MARGIN_PRECISION).div(new _1.BN(marginRatio)));
        }
        else {
            tradeAmount = _1.BN.max(numericConstants_1.ZERO, currentSpotMarketNetValue);
        }
        return tradeAmount;
    }
    // TODO - should this take the price impact of the trade into account for strict accuracy?
    /**
     * Returns the leverage ratio for the account after adding (or subtracting) the given quote size to the given position
     * @param targetMarketIndex
     * @param: targetMarketType
     * @param tradeQuoteAmount
     * @param tradeSide
     * @param includeOpenOrders
     * @returns leverageRatio : Precision TEN_THOUSAND
     */
    accountLeverageRatioAfterTrade(targetMarketIndex, targetMarketType, tradeQuoteAmount, tradeSide, includeOpenOrders = true) {
        const tradeIsPerp = (0, types_1.isVariant)(targetMarketType, 'perp');
        if (!tradeIsPerp) {
            // calculate new asset/liability values for base and quote market to find new account leverage
            const totalLiabilityValue = this.getTotalLiabilityValue();
            const totalAssetValue = this.getTotalAssetValue();
            const spotLiabilityValue = this.getSpotMarketLiabilityValue(undefined, undefined, undefined, includeOpenOrders);
            const currentQuoteAssetValue = this.getSpotMarketAssetValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, undefined, includeOpenOrders);
            const currentQuoteLiabilityValue = this.getSpotMarketLiabilityValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, undefined, undefined, includeOpenOrders);
            const currentQuoteValue = currentQuoteAssetValue.sub(currentQuoteLiabilityValue);
            const currentSpotMarketAssetValue = this.getSpotMarketAssetValue(targetMarketIndex, undefined, includeOpenOrders);
            const currentSpotMarketLiabilityValue = this.getSpotMarketLiabilityValue(targetMarketIndex, undefined, undefined, includeOpenOrders);
            const currentSpotMarketNetValue = currentSpotMarketAssetValue.sub(currentSpotMarketLiabilityValue);
            let assetValueToAdd = numericConstants_1.ZERO;
            let liabilityValueToAdd = numericConstants_1.ZERO;
            const newQuoteNetValue = tradeSide == _1.PositionDirection.SHORT
                ? currentQuoteValue.add(tradeQuoteAmount)
                : currentQuoteValue.sub(tradeQuoteAmount);
            const newQuoteAssetValue = _1.BN.max(newQuoteNetValue, numericConstants_1.ZERO);
            const newQuoteLiabilityValue = _1.BN.min(newQuoteNetValue, numericConstants_1.ZERO).abs();
            assetValueToAdd = assetValueToAdd.add(newQuoteAssetValue.sub(currentQuoteAssetValue));
            liabilityValueToAdd = liabilityValueToAdd.add(newQuoteLiabilityValue.sub(currentQuoteLiabilityValue));
            const newSpotMarketNetValue = tradeSide == _1.PositionDirection.LONG
                ? currentSpotMarketNetValue.add(tradeQuoteAmount)
                : currentSpotMarketNetValue.sub(tradeQuoteAmount);
            const newSpotMarketAssetValue = _1.BN.max(newSpotMarketNetValue, numericConstants_1.ZERO);
            const newSpotMarketLiabilityValue = _1.BN.min(newSpotMarketNetValue, numericConstants_1.ZERO).abs();
            assetValueToAdd = assetValueToAdd.add(newSpotMarketAssetValue.sub(currentSpotMarketAssetValue));
            liabilityValueToAdd = liabilityValueToAdd.add(newSpotMarketLiabilityValue.sub(currentSpotMarketLiabilityValue));
            const totalAssetValueAfterTrade = totalAssetValue.add(assetValueToAdd);
            const totalSpotLiabilityValueAfterTrade = spotLiabilityValue.add(liabilityValueToAdd);
            const totalLiabilityValueAfterTrade = totalLiabilityValue.add(liabilityValueToAdd);
            const netAssetValueAfterTrade = totalAssetValueAfterTrade.sub(totalSpotLiabilityValueAfterTrade);
            if (netAssetValueAfterTrade.eq(numericConstants_1.ZERO)) {
                return numericConstants_1.ZERO;
            }
            const newLeverage = totalLiabilityValueAfterTrade
                .mul(numericConstants_1.TEN_THOUSAND)
                .div(netAssetValueAfterTrade);
            return newLeverage;
        }
        const currentPosition = this.getPerpPosition(targetMarketIndex) ||
            this.getEmptyPosition(targetMarketIndex);
        const oracleData = this.getOracleDataForPerpMarket(targetMarketIndex);
        let currentPositionQuoteAmount = this.getPerpPositionValue(targetMarketIndex, oracleData, includeOpenOrders);
        const currentSide = currentPosition && currentPosition.baseAssetAmount.isNeg()
            ? _1.PositionDirection.SHORT
            : _1.PositionDirection.LONG;
        if (currentSide === _1.PositionDirection.SHORT)
            currentPositionQuoteAmount = currentPositionQuoteAmount.neg();
        if (tradeSide === _1.PositionDirection.SHORT)
            tradeQuoteAmount = tradeQuoteAmount.neg();
        const currentPerpPositionAfterTrade = currentPositionQuoteAmount
            .add(tradeQuoteAmount)
            .abs();
        const totalPositionAfterTradeExcludingTargetMarket = this.getTotalPerpPositionValueExcludingMarket(targetMarketIndex, undefined, undefined, includeOpenOrders);
        const totalAssetValue = this.getTotalAssetValue();
        const totalPerpPositionLiability = currentPerpPositionAfterTrade
            .add(totalPositionAfterTradeExcludingTargetMarket)
            .abs();
        const totalSpotLiability = this.getSpotMarketLiabilityValue(undefined, undefined, undefined, includeOpenOrders);
        const totalLiabilitiesAfterTrade = totalPerpPositionLiability.add(totalSpotLiability);
        const netAssetValue = totalAssetValue.sub(totalSpotLiability);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        const newLeverage = totalLiabilitiesAfterTrade
            .mul(numericConstants_1.TEN_THOUSAND)
            .div(netAssetValue);
        return newLeverage;
    }
    /**
     * Calculates how much fee will be taken for a given sized trade
     * @param quoteAmount
     * @returns feeForQuote : Precision QUOTE_PRECISION
     */
    calculateFeeForQuoteAmount(quoteAmount) {
        const feeTier = this.driftClient.getStateAccount().perpFeeStructure.feeTiers[0];
        return quoteAmount
            .mul(new _1.BN(feeTier.feeNumerator))
            .div(new _1.BN(feeTier.feeDenominator));
    }
    /**
     * Calculates a user's max withdrawal amounts for a spot market. If reduceOnly is true,
     * it will return the max withdrawal amount without opening a liability for the user
     * @param marketIndex
     * @returns withdrawalLimit : Precision is the token precision for the chosen SpotMarket
     */
    getWithdrawalLimit(marketIndex, reduceOnly) {
        const nowTs = new _1.BN(Math.floor(Date.now() / 1000));
        const spotMarket = this.driftClient.getSpotMarketAccount(marketIndex);
        // eslint-disable-next-line prefer-const
        let { borrowLimit, withdrawLimit } = (0, spotBalance_1.calculateWithdrawLimit)(spotMarket, nowTs);
        const freeCollateral = this.getFreeCollateral();
        const oracleData = this.getOracleDataForSpotMarket(marketIndex);
        const precisionIncrease = numericConstants_1.TEN.pow(new _1.BN(spotMarket.decimals - 6));
        const { canBypass, depositAmount: userDepositAmount } = this.canBypassWithdrawLimits(marketIndex);
        if (canBypass) {
            withdrawLimit = _1.BN.max(withdrawLimit, userDepositAmount);
        }
        const amountWithdrawable = freeCollateral
            .mul(numericConstants_1.MARGIN_PRECISION)
            .div(new _1.BN(spotMarket.initialAssetWeight))
            .mul(numericConstants_1.PRICE_PRECISION)
            .div(oracleData.price)
            .mul(precisionIncrease);
        const maxWithdrawValue = _1.BN.min(_1.BN.min(amountWithdrawable, userDepositAmount), withdrawLimit.abs());
        if (reduceOnly) {
            return _1.BN.max(maxWithdrawValue, numericConstants_1.ZERO);
        }
        else {
            const weightedAssetValue = this.getSpotMarketAssetValue(marketIndex, 'Initial', false);
            const freeCollatAfterWithdraw = userDepositAmount.gt(numericConstants_1.ZERO)
                ? freeCollateral.sub(weightedAssetValue)
                : freeCollateral;
            const maxLiabilityAllowed = freeCollatAfterWithdraw
                .mul(numericConstants_1.MARGIN_PRECISION)
                .div(new _1.BN(spotMarket.initialLiabilityWeight))
                .mul(numericConstants_1.PRICE_PRECISION)
                .div(oracleData.price)
                .mul(precisionIncrease);
            const maxBorrowValue = _1.BN.min(maxWithdrawValue.add(maxLiabilityAllowed), borrowLimit.abs());
            return _1.BN.max(maxBorrowValue, numericConstants_1.ZERO);
        }
    }
    canBypassWithdrawLimits(marketIndex) {
        const spotMarket = this.driftClient.getSpotMarketAccount(marketIndex);
        const maxDepositAmount = spotMarket.withdrawGuardThreshold.div(new _1.BN(10));
        const position = this.getSpotPosition(marketIndex);
        const netDeposits = this.getUserAccount().totalDeposits.sub(this.getUserAccount().totalWithdraws);
        if (!position) {
            return {
                canBypass: false,
                maxDepositAmount,
                depositAmount: numericConstants_1.ZERO,
                netDeposits,
            };
        }
        if ((0, types_1.isVariant)(position.balanceType, 'borrow')) {
            return {
                canBypass: false,
                maxDepositAmount,
                netDeposits,
                depositAmount: numericConstants_1.ZERO,
            };
        }
        const depositAmount = (0, spotBalance_1.getTokenAmount)(position.scaledBalance, spotMarket, _1.SpotBalanceType.DEPOSIT);
        if (netDeposits.lt(numericConstants_1.ZERO)) {
            return {
                canBypass: false,
                maxDepositAmount,
                depositAmount,
                netDeposits,
            };
        }
        return {
            canBypass: depositAmount.lt(maxDepositAmount),
            maxDepositAmount,
            netDeposits,
            depositAmount,
        };
    }
    canMakeIdle(slot, slotsBeforeIdle) {
        const userAccount = this.getUserAccount();
        if (userAccount.idle) {
            return false;
        }
        const userLastActiveSlot = userAccount.lastActiveSlot;
        const slotsSinceLastActive = slot.sub(userLastActiveSlot);
        if (slotsSinceLastActive.lt(slotsBeforeIdle)) {
            return false;
        }
        if (this.isBeingLiquidated()) {
            return false;
        }
        for (const perpPosition of userAccount.perpPositions) {
            if (!(0, position_1.positionIsAvailable)(perpPosition)) {
                return false;
            }
        }
        for (const spotPosition of userAccount.spotPositions) {
            if ((0, types_1.isVariant)(spotPosition.balanceType, 'borrow') &&
                spotPosition.scaledBalance.gt(numericConstants_1.ZERO)) {
                return false;
            }
            if (spotPosition.openOrders !== 0) {
                return false;
            }
        }
        for (const order of userAccount.orders) {
            if (!(0, types_1.isVariant)(order.status, 'init')) {
                return false;
            }
        }
        return true;
    }
    /**
     * Get the total position value, excluding any position coming from the given target market
     * @param marketToIgnore
     * @returns positionValue : Precision QUOTE_PRECISION
     */
    getTotalPerpPositionValueExcludingMarket(marketToIgnore, marginCategory, liquidationBuffer, includeOpenOrders) {
        const currentPerpPosition = this.getPerpPosition(marketToIgnore) ||
            this.getEmptyPosition(marketToIgnore);
        const oracleData = this.getOracleDataForPerpMarket(marketToIgnore);
        let currentPerpPositionValueUSDC = numericConstants_1.ZERO;
        if (currentPerpPosition) {
            currentPerpPositionValueUSDC = this.getPerpPositionValue(marketToIgnore, oracleData, includeOpenOrders);
        }
        return this.getTotalPerpPositionValue(marginCategory, liquidationBuffer, includeOpenOrders).sub(currentPerpPositionValueUSDC);
    }
    getOracleDataForPerpMarket(marketIndex) {
        const oracleKey = this.driftClient.getPerpMarketAccount(marketIndex).amm.oracle;
        const oracleData = this.driftClient.getOraclePriceDataAndSlot(oracleKey).data;
        return oracleData;
    }
    getOracleDataForSpotMarket(marketIndex) {
        const oracleKey = this.driftClient.getSpotMarketAccount(marketIndex).oracle;
        const oracleData = this.driftClient.getOraclePriceDataAndSlot(oracleKey).data;
        return oracleData;
    }
}
exports.User = User;
