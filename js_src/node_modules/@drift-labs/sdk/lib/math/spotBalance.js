"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateWithdrawLimit = exports.calculateInterestAccumulated = exports.calculateBorrowRate = exports.calculateDepositRate = exports.calculateInterestRate = exports.calculateUtilization = exports.calculateLiabilityWeight = exports.calculateAssetWeight = exports.getTokenValue = exports.getStrictTokenValue = exports.getSignedTokenAmount = exports.getTokenAmount = exports.getBalance = void 0;
const types_1 = require("../types");
const anchor_1 = require("@coral-xyz/anchor");
const numericConstants_1 = require("../constants/numericConstants");
const margin_1 = require("./margin");
const numericConstants_2 = require("../constants/numericConstants");
const utils_1 = require("./utils");
function getBalance(tokenAmount, spotMarket, balanceType) {
    const precisionIncrease = numericConstants_1.TEN.pow(new anchor_1.BN(19 - spotMarket.decimals));
    const cumulativeInterest = (0, types_1.isVariant)(balanceType, 'deposit')
        ? spotMarket.cumulativeDepositInterest
        : spotMarket.cumulativeBorrowInterest;
    let balance = tokenAmount.mul(precisionIncrease).div(cumulativeInterest);
    if (!balance.eq(numericConstants_1.ZERO) && (0, types_1.isVariant)(balanceType, 'borrow')) {
        balance = balance.add(numericConstants_1.ONE);
    }
    return balance;
}
exports.getBalance = getBalance;
function getTokenAmount(balanceAmount, spotMarket, balanceType) {
    const precisionDecrease = numericConstants_1.TEN.pow(new anchor_1.BN(19 - spotMarket.decimals));
    if ((0, types_1.isVariant)(balanceType, 'deposit')) {
        return balanceAmount
            .mul(spotMarket.cumulativeDepositInterest)
            .div(precisionDecrease);
    }
    else {
        return (0, utils_1.divCeil)(balanceAmount.mul(spotMarket.cumulativeBorrowInterest), precisionDecrease);
    }
}
exports.getTokenAmount = getTokenAmount;
function getSignedTokenAmount(tokenAmount, balanceType) {
    if ((0, types_1.isVariant)(balanceType, 'deposit')) {
        return tokenAmount;
    }
    else {
        return tokenAmount.abs().neg();
    }
}
exports.getSignedTokenAmount = getSignedTokenAmount;
function getStrictTokenValue(tokenAmount, spotDecimals, oraclePriceData, oraclePriceTwap) {
    if (tokenAmount.eq(numericConstants_1.ZERO)) {
        return numericConstants_1.ZERO;
    }
    let price = oraclePriceData.price;
    if (tokenAmount.gt(numericConstants_1.ZERO)) {
        price = anchor_1.BN.min(oraclePriceData.price, oraclePriceTwap);
    }
    else {
        price = anchor_1.BN.max(oraclePriceData.price, oraclePriceTwap);
    }
    const precisionDecrease = numericConstants_1.TEN.pow(new anchor_1.BN(spotDecimals));
    return tokenAmount.mul(price).div(precisionDecrease);
}
exports.getStrictTokenValue = getStrictTokenValue;
function getTokenValue(tokenAmount, spotDecimals, oraclePriceData) {
    if (tokenAmount.eq(numericConstants_1.ZERO)) {
        return numericConstants_1.ZERO;
    }
    const precisionDecrease = numericConstants_1.TEN.pow(new anchor_1.BN(spotDecimals));
    return tokenAmount.mul(oraclePriceData.price).div(precisionDecrease);
}
exports.getTokenValue = getTokenValue;
function calculateAssetWeight(balanceAmount, spotMarket, marginCategory) {
    const sizePrecision = numericConstants_1.TEN.pow(new anchor_1.BN(spotMarket.decimals));
    let sizeInAmmReservePrecision;
    if (sizePrecision.gt(numericConstants_1.AMM_RESERVE_PRECISION)) {
        sizeInAmmReservePrecision = balanceAmount.div(sizePrecision.div(numericConstants_1.AMM_RESERVE_PRECISION));
    }
    else {
        sizeInAmmReservePrecision = balanceAmount
            .mul(numericConstants_1.AMM_RESERVE_PRECISION)
            .div(sizePrecision);
    }
    let assetWeight;
    switch (marginCategory) {
        case 'Initial':
            assetWeight = (0, margin_1.calculateSizeDiscountAssetWeight)(sizeInAmmReservePrecision, new anchor_1.BN(spotMarket.imfFactor), new anchor_1.BN(spotMarket.initialAssetWeight));
            break;
        case 'Maintenance':
            assetWeight = (0, margin_1.calculateSizeDiscountAssetWeight)(sizeInAmmReservePrecision, new anchor_1.BN(spotMarket.imfFactor), new anchor_1.BN(spotMarket.maintenanceAssetWeight));
            break;
        default:
            assetWeight = new anchor_1.BN(spotMarket.initialAssetWeight);
            break;
    }
    return assetWeight;
}
exports.calculateAssetWeight = calculateAssetWeight;
function calculateLiabilityWeight(size, spotMarket, marginCategory) {
    const sizePrecision = numericConstants_1.TEN.pow(new anchor_1.BN(spotMarket.decimals));
    let sizeInAmmReservePrecision;
    if (sizePrecision.gt(numericConstants_1.AMM_RESERVE_PRECISION)) {
        sizeInAmmReservePrecision = size.div(sizePrecision.div(numericConstants_1.AMM_RESERVE_PRECISION));
    }
    else {
        sizeInAmmReservePrecision = size
            .mul(numericConstants_1.AMM_RESERVE_PRECISION)
            .div(sizePrecision);
    }
    let liabilityWeight;
    switch (marginCategory) {
        case 'Initial':
            liabilityWeight = (0, margin_1.calculateSizePremiumLiabilityWeight)(sizeInAmmReservePrecision, new anchor_1.BN(spotMarket.imfFactor), new anchor_1.BN(spotMarket.initialLiabilityWeight), numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION);
            break;
        case 'Maintenance':
            liabilityWeight = (0, margin_1.calculateSizePremiumLiabilityWeight)(sizeInAmmReservePrecision, new anchor_1.BN(spotMarket.imfFactor), new anchor_1.BN(spotMarket.maintenanceLiabilityWeight), numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION);
            break;
        default:
            liabilityWeight = spotMarket.initialLiabilityWeight;
            break;
    }
    return liabilityWeight;
}
exports.calculateLiabilityWeight = calculateLiabilityWeight;
function calculateUtilization(bank) {
    const tokenDepositAmount = getTokenAmount(bank.depositBalance, bank, types_1.SpotBalanceType.DEPOSIT);
    const tokenBorrowAmount = getTokenAmount(bank.borrowBalance, bank, types_1.SpotBalanceType.BORROW);
    let utilization;
    if (tokenBorrowAmount.eq(numericConstants_1.ZERO) && tokenDepositAmount.eq(numericConstants_1.ZERO)) {
        utilization = numericConstants_1.ZERO;
    }
    else if (tokenDepositAmount.eq(numericConstants_1.ZERO)) {
        utilization = numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION;
    }
    else {
        utilization = tokenBorrowAmount
            .mul(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION)
            .div(tokenDepositAmount);
    }
    return utilization;
}
exports.calculateUtilization = calculateUtilization;
function calculateInterestRate(bank) {
    const utilization = calculateUtilization(bank);
    let interestRate;
    if (utilization.gt(new anchor_1.BN(bank.optimalUtilization))) {
        const surplusUtilization = utilization.sub(new anchor_1.BN(bank.optimalUtilization));
        const borrowRateSlope = new anchor_1.BN(bank.maxBorrowRate - bank.optimalBorrowRate)
            .mul(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION)
            .div(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION.sub(new anchor_1.BN(bank.optimalUtilization)));
        interestRate = new anchor_1.BN(bank.optimalBorrowRate).add(surplusUtilization
            .mul(borrowRateSlope)
            .div(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION));
    }
    else {
        const borrowRateSlope = new anchor_1.BN(bank.optimalBorrowRate)
            .mul(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION)
            .div(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION.sub(new anchor_1.BN(bank.optimalUtilization)));
        interestRate = utilization
            .mul(borrowRateSlope)
            .div(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION);
    }
    return interestRate;
}
exports.calculateInterestRate = calculateInterestRate;
function calculateDepositRate(bank) {
    const utilization = calculateUtilization(bank);
    const borrowRate = calculateBorrowRate(bank);
    const depositRate = borrowRate
        .mul(numericConstants_2.PERCENTAGE_PRECISION.sub(new anchor_1.BN(bank.insuranceFund.totalFactor)))
        .mul(utilization)
        .div(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION)
        .div(numericConstants_2.PERCENTAGE_PRECISION);
    return depositRate;
}
exports.calculateDepositRate = calculateDepositRate;
function calculateBorrowRate(bank) {
    return calculateInterestRate(bank);
}
exports.calculateBorrowRate = calculateBorrowRate;
function calculateInterestAccumulated(bank, now) {
    const interestRate = calculateInterestRate(bank);
    const timeSinceLastUpdate = now.sub(bank.lastInterestTs);
    const modifiedBorrowRate = interestRate.mul(timeSinceLastUpdate);
    const utilization = calculateUtilization(bank);
    const modifiedDepositRate = modifiedBorrowRate
        .mul(utilization)
        .div(numericConstants_1.SPOT_MARKET_UTILIZATION_PRECISION);
    const borrowInterest = bank.cumulativeBorrowInterest
        .mul(modifiedBorrowRate)
        .div(numericConstants_1.ONE_YEAR)
        .div(numericConstants_1.SPOT_MARKET_RATE_PRECISION)
        .add(numericConstants_1.ONE);
    const depositInterest = bank.cumulativeDepositInterest
        .mul(modifiedDepositRate)
        .div(numericConstants_1.ONE_YEAR)
        .div(numericConstants_1.SPOT_MARKET_RATE_PRECISION);
    return { borrowInterest, depositInterest };
}
exports.calculateInterestAccumulated = calculateInterestAccumulated;
function calculateWithdrawLimit(spotMarket, now) {
    const marketDepositTokenAmount = getTokenAmount(spotMarket.depositBalance, spotMarket, types_1.SpotBalanceType.DEPOSIT);
    const marketBorrowTokenAmount = getTokenAmount(spotMarket.borrowBalance, spotMarket, types_1.SpotBalanceType.BORROW);
    const twentyFourHours = new anchor_1.BN(60 * 60 * 24);
    const sinceLast = now.sub(spotMarket.lastTwapTs);
    const sinceStart = anchor_1.BN.max(numericConstants_1.ZERO, twentyFourHours.sub(sinceLast));
    const borrowTokenTwapLive = spotMarket.borrowTokenTwap
        .mul(sinceStart)
        .add(marketBorrowTokenAmount.mul(sinceLast))
        .div(sinceLast.add(sinceStart));
    const depositTokenTwapLive = spotMarket.depositTokenTwap
        .mul(sinceStart)
        .add(marketDepositTokenAmount.mul(sinceLast))
        .div(sinceLast.add(sinceStart));
    const maxBorrowTokens = anchor_1.BN.max(spotMarket.withdrawGuardThreshold, anchor_1.BN.min(anchor_1.BN.max(marketDepositTokenAmount.div(new anchor_1.BN(6)), borrowTokenTwapLive.add(marketDepositTokenAmount.div(new anchor_1.BN(10)))), marketDepositTokenAmount.sub(marketDepositTokenAmount.div(new anchor_1.BN(5))))); // between ~15-80% utilization with friction on twap
    const minDepositTokens = depositTokenTwapLive.sub(anchor_1.BN.max(depositTokenTwapLive.div(new anchor_1.BN(4)), anchor_1.BN.min(spotMarket.withdrawGuardThreshold, depositTokenTwapLive)));
    const withdrawLimit = anchor_1.BN.max(marketDepositTokenAmount.sub(minDepositTokens), numericConstants_1.ZERO);
    let borrowLimit = maxBorrowTokens.sub(marketBorrowTokenAmount);
    borrowLimit = anchor_1.BN.min(borrowLimit, marketDepositTokenAmount.sub(marketBorrowTokenAmount));
    if (withdrawLimit.eq(numericConstants_1.ZERO)) {
        borrowLimit = numericConstants_1.ZERO;
    }
    return {
        borrowLimit,
        withdrawLimit,
        maxBorrowAmount: maxBorrowTokens,
        minDepositAmount: minDepositTokens,
        currentDepositAmount: marketDepositTokenAmount,
        currentBorrowAmount: marketBorrowTokenAmount,
    };
}
exports.calculateWithdrawLimit = calculateWithdrawLimit;
