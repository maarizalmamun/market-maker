"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateLiveOracleStd = exports.calculateLiveOracleTwap = exports.isOracleTooDivergent = exports.isOracleValid = exports.oraclePriceBands = void 0;
const numericConstants_1 = require("../constants/numericConstants");
const index_1 = require("../index");
const assert_1 = require("../assert/assert");
function oraclePriceBands(market, oraclePriceData) {
    const maxPercentDiff = market.marginRatioInitial - market.marginRatioMaintenance;
    const offset = oraclePriceData.price
        .mul(new index_1.BN(maxPercentDiff))
        .div(numericConstants_1.MARGIN_PRECISION);
    (0, assert_1.assert)(offset.gt(numericConstants_1.ZERO));
    return [oraclePriceData.price.sub(offset), oraclePriceData.price.add(offset)];
}
exports.oraclePriceBands = oraclePriceBands;
function isOracleValid(amm, oraclePriceData, oracleGuardRails, slot) {
    const isOraclePriceNonPositive = oraclePriceData.price.lte(numericConstants_1.ZERO);
    const isOraclePriceTooVolatile = oraclePriceData.price
        .div(index_1.BN.max(numericConstants_1.ONE, amm.historicalOracleData.lastOraclePriceTwap))
        .gt(oracleGuardRails.validity.tooVolatileRatio) ||
        amm.historicalOracleData.lastOraclePriceTwap
            .div(index_1.BN.max(numericConstants_1.ONE, oraclePriceData.price))
            .gt(oracleGuardRails.validity.tooVolatileRatio);
    const isConfidenceTooLarge = index_1.BN.max(numericConstants_1.ONE, oraclePriceData.confidence)
        .mul(numericConstants_1.BID_ASK_SPREAD_PRECISION)
        .div(oraclePriceData.price)
        .gt(oracleGuardRails.validity.confidenceIntervalMaxSize);
    const oracleIsStale = oraclePriceData.slot
        .sub(new index_1.BN(slot))
        .gt(oracleGuardRails.validity.slotsBeforeStaleForAmm);
    return !(!oraclePriceData.hasSufficientNumberOfDataPoints ||
        oracleIsStale ||
        isOraclePriceNonPositive ||
        isOraclePriceTooVolatile ||
        isConfidenceTooLarge);
}
exports.isOracleValid = isOracleValid;
function isOracleTooDivergent(amm, oraclePriceData, oracleGuardRails, now) {
    const sinceLastUpdate = now.sub(amm.historicalOracleData.lastOraclePriceTwapTs);
    const sinceStart = index_1.BN.max(numericConstants_1.ZERO, numericConstants_1.FIVE_MINUTE.sub(sinceLastUpdate));
    const oracleTwap5min = amm.historicalOracleData.lastOraclePriceTwap5Min
        .mul(sinceStart)
        .add(oraclePriceData.price)
        .mul(sinceLastUpdate)
        .div(sinceStart.add(sinceLastUpdate));
    const oracleSpread = oracleTwap5min.sub(oraclePriceData.price);
    const oracleSpreadPct = oracleSpread.mul(numericConstants_1.PRICE_PRECISION).div(oracleTwap5min);
    const tooDivergent = oracleSpreadPct
        .abs()
        .gte(numericConstants_1.BID_ASK_SPREAD_PRECISION.mul(oracleGuardRails.priceDivergence.markOracleDivergenceNumerator).div(oracleGuardRails.priceDivergence.markOracleDivergenceDenominator));
    return tooDivergent;
}
exports.isOracleTooDivergent = isOracleTooDivergent;
function calculateLiveOracleTwap(histOracleData, oraclePriceData, now, period) {
    let oracleTwap = undefined;
    if (period.eq(numericConstants_1.FIVE_MINUTE)) {
        oracleTwap = histOracleData.lastOraclePriceTwap5Min;
    }
    else {
        //todo: assumes its fundingPeriod (1hr)
        // period = amm.fundingPeriod;
        oracleTwap = histOracleData.lastOraclePriceTwap;
    }
    const sinceLastUpdate = index_1.BN.max(numericConstants_1.ONE, now.sub(histOracleData.lastOraclePriceTwapTs));
    const sinceStart = index_1.BN.max(numericConstants_1.ZERO, period.sub(sinceLastUpdate));
    const clampRange = oracleTwap.div(new index_1.BN(3));
    const clampedOraclePrice = index_1.BN.min(oracleTwap.add(clampRange), index_1.BN.max(oraclePriceData.price, oracleTwap.sub(clampRange)));
    const newOracleTwap = oracleTwap
        .mul(sinceStart)
        .add(clampedOraclePrice.mul(sinceLastUpdate))
        .div(sinceStart.add(sinceLastUpdate));
    return newOracleTwap;
}
exports.calculateLiveOracleTwap = calculateLiveOracleTwap;
function calculateLiveOracleStd(amm, oraclePriceData, now) {
    const sinceLastUpdate = index_1.BN.max(numericConstants_1.ONE, now.sub(amm.historicalOracleData.lastOraclePriceTwapTs));
    const sinceStart = index_1.BN.max(numericConstants_1.ZERO, amm.fundingPeriod.sub(sinceLastUpdate));
    const liveOracleTwap = calculateLiveOracleTwap(amm.historicalOracleData, oraclePriceData, now, amm.fundingPeriod);
    const priceDeltaVsTwap = oraclePriceData.price.sub(liveOracleTwap).abs();
    const oracleStd = priceDeltaVsTwap.add(amm.oracleStd.mul(sinceStart).div(sinceStart.add(sinceLastUpdate)));
    return oracleStd;
}
exports.calculateLiveOracleStd = calculateLiveOracleStd;
