"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAuctionPriceForOracleOffsetAuction = exports.getAuctionPriceForFixedAuction = exports.getAuctionPrice = exports.isFallbackAvailableLiquiditySource = exports.isAuctionComplete = void 0;
const types_1 = require("../types");
const _1 = require("../.");
function isAuctionComplete(order, slot) {
    if (order.auctionDuration === 0) {
        return true;
    }
    return new _1.BN(slot).sub(order.slot).gt(new _1.BN(order.auctionDuration));
}
exports.isAuctionComplete = isAuctionComplete;
function isFallbackAvailableLiquiditySource(order, minAuctionDuration, slot) {
    if (minAuctionDuration === 0) {
        return true;
    }
    return new _1.BN(slot).sub(order.slot).gt(new _1.BN(minAuctionDuration));
}
exports.isFallbackAvailableLiquiditySource = isFallbackAvailableLiquiditySource;
function getAuctionPrice(order, slot, oraclePrice) {
    if ((0, types_1.isOneOfVariant)(order.orderType, ['market', 'triggerMarket', 'limit'])) {
        return getAuctionPriceForFixedAuction(order, slot);
    }
    else if ((0, types_1.isVariant)(order.orderType, 'oracle')) {
        return getAuctionPriceForOracleOffsetAuction(order, slot, oraclePrice);
    }
    else {
        throw Error(`Cant get auction price for order type ${order.orderType}`);
    }
}
exports.getAuctionPrice = getAuctionPrice;
function getAuctionPriceForFixedAuction(order, slot) {
    const slotsElapsed = new _1.BN(slot).sub(order.slot);
    const deltaDenominator = new _1.BN(order.auctionDuration);
    const deltaNumerator = _1.BN.min(slotsElapsed, deltaDenominator);
    if (deltaDenominator.eq(_1.ZERO)) {
        return order.auctionEndPrice;
    }
    let priceDelta;
    if ((0, types_1.isVariant)(order.direction, 'long')) {
        priceDelta = order.auctionEndPrice
            .sub(order.auctionStartPrice)
            .mul(deltaNumerator)
            .div(deltaDenominator);
    }
    else {
        priceDelta = order.auctionStartPrice
            .sub(order.auctionEndPrice)
            .mul(deltaNumerator)
            .div(deltaDenominator);
    }
    let price;
    if ((0, types_1.isVariant)(order.direction, 'long')) {
        price = order.auctionStartPrice.add(priceDelta);
    }
    else {
        price = order.auctionStartPrice.sub(priceDelta);
    }
    return price;
}
exports.getAuctionPriceForFixedAuction = getAuctionPriceForFixedAuction;
function getAuctionPriceForOracleOffsetAuction(order, slot, oraclePrice) {
    const slotsElapsed = new _1.BN(slot).sub(order.slot);
    const deltaDenominator = new _1.BN(order.auctionDuration);
    const deltaNumerator = _1.BN.min(slotsElapsed, deltaDenominator);
    if (deltaDenominator.eq(_1.ZERO)) {
        return order.auctionEndPrice.add(order.auctionEndPrice);
    }
    let priceOffsetDelta;
    if ((0, types_1.isVariant)(order.direction, 'long')) {
        priceOffsetDelta = order.auctionEndPrice
            .sub(order.auctionStartPrice)
            .mul(deltaNumerator)
            .div(deltaDenominator);
    }
    else {
        priceOffsetDelta = order.auctionStartPrice
            .sub(order.auctionEndPrice)
            .mul(deltaNumerator)
            .div(deltaDenominator);
    }
    let priceOffset;
    if ((0, types_1.isVariant)(order.direction, 'long')) {
        priceOffset = order.auctionStartPrice.add(priceOffsetDelta);
    }
    else {
        priceOffset = order.auctionStartPrice.sub(priceOffsetDelta);
    }
    return oraclePrice.add(priceOffset);
}
exports.getAuctionPriceForOracleOffsetAuction = getAuctionPriceForOracleOffsetAuction;
