"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateFundingPool = exports.calculateLongShortFundingRateAndLiveTwaps = exports.calculateLongShortFundingRate = exports.calculateEstimatedFundingRate = exports.calculateAllEstimatedFundingRate = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const numericConstants_1 = require("../constants/numericConstants");
const types_1 = require("../types");
const amm_1 = require("./amm");
/**
 *
 * @param market
 * @param oraclePriceData
 * @param periodAdjustment
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
async function calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1), now) {
    // periodAdjustment
    // 	1: hourly
    //  24: daily
    //  24 * 365.25: annualized
    const secondsInHour = new anchor_1.BN(3600);
    const hoursInDay = new anchor_1.BN(24);
    const ONE = new anchor_1.BN(1);
    if ((0, types_1.isVariant)(market.status, 'uninitialized')) {
        return [numericConstants_1.ZERO, numericConstants_1.ZERO, numericConstants_1.ZERO, numericConstants_1.ZERO, numericConstants_1.ZERO];
    }
    const payFreq = new anchor_1.BN(market.amm.fundingPeriod);
    // todo: sufficiently differs from blockchain timestamp?
    now = now || new anchor_1.BN((Date.now() / 1000).toFixed(0));
    const timeSinceLastUpdate = now.sub(market.amm.lastFundingRateTs);
    // calculate real-time mark twap
    const lastMarkTwapWithMantissa = market.amm.lastMarkPriceTwap;
    const lastMarkPriceTwapTs = market.amm.lastMarkPriceTwapTs;
    const timeSinceLastMarkChange = now.sub(lastMarkPriceTwapTs);
    const markTwapTimeSinceLastUpdate = anchor_1.BN.max(secondsInHour, anchor_1.BN.max(numericConstants_1.ZERO, secondsInHour.sub(timeSinceLastMarkChange)));
    const [bid, ask] = (0, amm_1.calculateBidAskPrice)(market.amm, oraclePriceData);
    const baseAssetPriceWithMantissa = bid.add(ask).div(new anchor_1.BN(2));
    const markTwapWithMantissa = markTwapTimeSinceLastUpdate
        .mul(lastMarkTwapWithMantissa)
        .add(timeSinceLastMarkChange.mul(baseAssetPriceWithMantissa))
        .div(timeSinceLastMarkChange.add(markTwapTimeSinceLastUpdate));
    // calculate real-time (predicted) oracle twap
    // note: oracle twap depends on `when the chord is struck` (market is trade)
    const lastOracleTwapWithMantissa = market.amm.historicalOracleData.lastOraclePriceTwap;
    const lastOraclePriceTwapTs = market.amm.historicalOracleData.lastOraclePriceTwapTs;
    const oracleInvalidDuration = anchor_1.BN.max(numericConstants_1.ZERO, lastMarkPriceTwapTs.sub(lastOraclePriceTwapTs));
    const timeSinceLastOracleTwapUpdate = now.sub(lastOraclePriceTwapTs);
    const oracleTwapTimeSinceLastUpdate = anchor_1.BN.max(ONE, anchor_1.BN.min(secondsInHour, anchor_1.BN.max(ONE, secondsInHour.sub(timeSinceLastOracleTwapUpdate))));
    let oracleTwapWithMantissa = lastOracleTwapWithMantissa;
    // if passing live oracle data, improve predicted calc estimate
    if (oraclePriceData) {
        const oraclePrice = oraclePriceData.price;
        const oracleLiveVsTwap = oraclePrice
            .sub(lastOracleTwapWithMantissa)
            .abs()
            .mul(numericConstants_1.PRICE_PRECISION)
            .mul(new anchor_1.BN(100))
            .div(lastOracleTwapWithMantissa);
        // verify pyth live input is within 20% of last twap for live update
        if (oracleLiveVsTwap.lte(numericConstants_1.PRICE_PRECISION.mul(new anchor_1.BN(20)))) {
            oracleTwapWithMantissa = oracleTwapTimeSinceLastUpdate
                .mul(lastOracleTwapWithMantissa)
                .add(timeSinceLastMarkChange.mul(oraclePrice))
                .div(timeSinceLastMarkChange.add(oracleTwapTimeSinceLastUpdate));
        }
    }
    const shrunkLastOracleTwapwithMantissa = oracleTwapTimeSinceLastUpdate
        .mul(oracleTwapWithMantissa)
        .add(oracleInvalidDuration.mul(lastMarkTwapWithMantissa))
        .div(oracleTwapTimeSinceLastUpdate.add(oracleInvalidDuration));
    const twapSpread = markTwapWithMantissa.sub(shrunkLastOracleTwapwithMantissa);
    const twapSpreadPct = twapSpread
        .mul(numericConstants_1.PRICE_PRECISION)
        .mul(new anchor_1.BN(100))
        .div(shrunkLastOracleTwapwithMantissa);
    const lowerboundEst = twapSpreadPct
        .mul(payFreq)
        .mul(anchor_1.BN.min(secondsInHour, timeSinceLastUpdate))
        .mul(periodAdjustment)
        .div(secondsInHour)
        .div(secondsInHour)
        .div(hoursInDay);
    const interpEst = twapSpreadPct.mul(periodAdjustment).div(hoursInDay);
    const interpRateQuote = twapSpreadPct
        .mul(periodAdjustment)
        .div(hoursInDay)
        .div(numericConstants_1.PRICE_PRECISION.div(numericConstants_1.QUOTE_PRECISION));
    let feePoolSize = calculateFundingPool(market);
    if (interpRateQuote.lt(new anchor_1.BN(0))) {
        feePoolSize = feePoolSize.mul(new anchor_1.BN(-1));
    }
    let cappedAltEst;
    let largerSide;
    let smallerSide;
    if (market.amm.baseAssetAmountLong.gt(market.amm.baseAssetAmountShort.abs())) {
        largerSide = market.amm.baseAssetAmountLong.abs();
        smallerSide = market.amm.baseAssetAmountShort.abs();
        if (twapSpread.gt(new anchor_1.BN(0))) {
            return [
                markTwapWithMantissa,
                oracleTwapWithMantissa,
                lowerboundEst,
                interpEst,
                interpEst,
            ];
        }
    }
    else if (market.amm.baseAssetAmountLong.lt(market.amm.baseAssetAmountShort.abs())) {
        largerSide = market.amm.baseAssetAmountShort.abs();
        smallerSide = market.amm.baseAssetAmountLong.abs();
        if (twapSpread.lt(new anchor_1.BN(0))) {
            return [
                markTwapWithMantissa,
                oracleTwapWithMantissa,
                lowerboundEst,
                interpEst,
                interpEst,
            ];
        }
    }
    else {
        return [
            markTwapWithMantissa,
            oracleTwapWithMantissa,
            lowerboundEst,
            interpEst,
            interpEst,
        ];
    }
    if (largerSide.gt(numericConstants_1.ZERO)) {
        // funding smaller flow
        cappedAltEst = smallerSide.mul(twapSpread).div(hoursInDay);
        const feePoolTopOff = feePoolSize
            .mul(numericConstants_1.PRICE_PRECISION.div(numericConstants_1.QUOTE_PRECISION))
            .mul(numericConstants_1.AMM_RESERVE_PRECISION);
        cappedAltEst = cappedAltEst.add(feePoolTopOff).div(largerSide);
        cappedAltEst = cappedAltEst
            .mul(numericConstants_1.PRICE_PRECISION)
            .mul(new anchor_1.BN(100))
            .div(oracleTwapWithMantissa)
            .mul(periodAdjustment);
        if (cappedAltEst.abs().gte(interpEst.abs())) {
            cappedAltEst = interpEst;
        }
    }
    else {
        cappedAltEst = interpEst;
    }
    return [
        markTwapWithMantissa,
        oracleTwapWithMantissa,
        lowerboundEst,
        cappedAltEst,
        interpEst,
    ];
}
exports.calculateAllEstimatedFundingRate = calculateAllEstimatedFundingRate;
/**
 *
 * @param market
 * @param oraclePriceData
 * @param periodAdjustment
 * @param estimationMethod
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
async function calculateEstimatedFundingRate(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1), estimationMethod) {
    const [_1, _2, lowerboundEst, cappedAltEst, interpEst] = await calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment);
    if (estimationMethod == 'lowerbound') {
        //assuming remaining funding period has no gap
        return lowerboundEst;
    }
    else if (estimationMethod == 'capped') {
        return cappedAltEst;
    }
    else {
        return interpEst;
    }
}
exports.calculateEstimatedFundingRate = calculateEstimatedFundingRate;
/**
 *
 * @param market
 * @param oraclePriceData
 * @param periodAdjustment
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
async function calculateLongShortFundingRate(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1)) {
    const [_1, _2, _, cappedAltEst, interpEst] = await calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment);
    if (market.amm.baseAssetAmountLong.gt(market.amm.baseAssetAmountShort)) {
        return [cappedAltEst, interpEst];
    }
    else if (market.amm.baseAssetAmountLong.lt(market.amm.baseAssetAmountShort)) {
        return [interpEst, cappedAltEst];
    }
    else {
        return [interpEst, interpEst];
    }
}
exports.calculateLongShortFundingRate = calculateLongShortFundingRate;
/**
 *
 * @param market
 * @param oraclePriceData
 * @param periodAdjustment
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
async function calculateLongShortFundingRateAndLiveTwaps(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1)) {
    const [markTwapLive, oracleTwapLive, _2, cappedAltEst, interpEst] = await calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment);
    if (market.amm.baseAssetAmountLong.gt(market.amm.baseAssetAmountShort.abs())) {
        return [markTwapLive, oracleTwapLive, cappedAltEst, interpEst];
    }
    else if (market.amm.baseAssetAmountLong.lt(market.amm.baseAssetAmountShort.abs())) {
        return [markTwapLive, oracleTwapLive, interpEst, cappedAltEst];
    }
    else {
        return [markTwapLive, oracleTwapLive, interpEst, interpEst];
    }
}
exports.calculateLongShortFundingRateAndLiveTwaps = calculateLongShortFundingRateAndLiveTwaps;
/**
 *
 * @param market
 * @returns Estimated fee pool size
 */
function calculateFundingPool(market) {
    // todo
    const totalFeeLB = market.amm.totalExchangeFee.div(new anchor_1.BN(2));
    const feePool = anchor_1.BN.max(numericConstants_1.ZERO, market.amm.totalFeeMinusDistributions
        .sub(totalFeeLB)
        .mul(new anchor_1.BN(1))
        .div(new anchor_1.BN(3)));
    return feePool;
}
exports.calculateFundingPool = calculateFundingPool;
