"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketAccountSubscriber = void 0;
const utils_1 = require("./utils");
class WebSocketAccountSubscriber {
    constructor(accountName, program, accountPublicKey, decodeBuffer) {
        this.accountName = accountName;
        this.program = program;
        this.accountPublicKey = accountPublicKey;
        this.decodeBufferFn = decodeBuffer;
    }
    async subscribe(onChange) {
        if (this.listenerId) {
            return;
        }
        this.onChange = onChange;
        if (!this.dataAndSlot) {
            await this.fetch();
        }
        this.listenerId = this.program.provider.connection.onAccountChange(this.accountPublicKey, (accountInfo, context) => {
            this.handleRpcResponse(context, accountInfo);
        }, this.program.provider.opts.commitment);
    }
    setData(data, slot) {
        const newSlot = slot || 0;
        if (this.dataAndSlot && this.dataAndSlot.slot > newSlot) {
            return;
        }
        this.dataAndSlot = {
            data,
            slot,
        };
    }
    async fetch() {
        const rpcResponse = await this.program.provider.connection.getAccountInfoAndContext(this.accountPublicKey, this.program.provider.opts.commitment);
        this.handleRpcResponse(rpcResponse.context, rpcResponse === null || rpcResponse === void 0 ? void 0 : rpcResponse.value);
    }
    handleRpcResponse(context, accountInfo) {
        const newSlot = context.slot;
        let newBuffer = undefined;
        if (accountInfo) {
            newBuffer = accountInfo.data;
        }
        if (!this.bufferAndSlot) {
            this.bufferAndSlot = {
                buffer: newBuffer,
                slot: newSlot,
            };
            if (newBuffer) {
                const account = this.decodeBuffer(newBuffer);
                this.dataAndSlot = {
                    data: account,
                    slot: newSlot,
                };
                this.onChange(account);
            }
            return;
        }
        if (newSlot <= this.bufferAndSlot.slot) {
            return;
        }
        const oldBuffer = this.bufferAndSlot.buffer;
        if (newBuffer && (!oldBuffer || !newBuffer.equals(oldBuffer))) {
            this.bufferAndSlot = {
                buffer: newBuffer,
                slot: newSlot,
            };
            const account = this.decodeBuffer(newBuffer);
            this.dataAndSlot = {
                data: account,
                slot: newSlot,
            };
            this.onChange(account);
        }
    }
    decodeBuffer(buffer) {
        if (this.decodeBufferFn) {
            return this.decodeBufferFn(buffer);
        }
        else {
            return this.program.account[this.accountName].coder.accounts.decode((0, utils_1.capitalize)(this.accountName), buffer);
        }
    }
    unsubscribe() {
        if (this.listenerId) {
            const promise = this.program.provider.connection.removeAccountChangeListener(this.listenerId);
            this.listenerId = undefined;
            return promise;
        }
    }
}
exports.WebSocketAccountSubscriber = WebSocketAccountSubscriber;
