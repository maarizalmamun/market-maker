"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingDriftClientAccountSubscriber = void 0;
const types_1 = require("./types");
const events_1 = require("events");
const pda_1 = require("../addresses/pda");
const utils_1 = require("./utils");
const web3_js_1 = require("@solana/web3.js");
const oracleClientCache_1 = require("../oracles/oracleClientCache");
const quoteAssetOracleClient_1 = require("../oracles/quoteAssetOracleClient");
class PollingDriftClientAccountSubscriber {
    constructor(program, accountLoader, perpMarketIndexes, spotMarketIndexes, oracleInfos) {
        this.oracleClientCache = new oracleClientCache_1.OracleClientCache();
        this.accountsToPoll = new Map();
        this.oraclesToPoll = new Map();
        this.perpMarket = new Map();
        this.spotMarket = new Map();
        this.oracles = new Map();
        this.isSubscribing = false;
        this.isSubscribed = false;
        this.program = program;
        this.eventEmitter = new events_1.EventEmitter();
        this.accountLoader = accountLoader;
        this.perpMarketIndexes = perpMarketIndexes;
        this.spotMarketIndexes = spotMarketIndexes;
        this.oracleInfos = oracleInfos;
    }
    async subscribe() {
        if (this.isSubscribed) {
            return true;
        }
        if (this.isSubscribing) {
            return await this.subscriptionPromise;
        }
        this.isSubscribing = true;
        this.subscriptionPromise = new Promise((res) => {
            this.subscriptionPromiseResolver = res;
        });
        await this.updateAccountsToPoll();
        await this.updateOraclesToPoll();
        await this.addToAccountLoader();
        let subscriptionSucceeded = false;
        let retries = 0;
        while (!subscriptionSucceeded && retries < 5) {
            await this.fetch();
            subscriptionSucceeded = this.didSubscriptionSucceed();
            retries++;
        }
        if (subscriptionSucceeded) {
            this.eventEmitter.emit('update');
        }
        this.isSubscribing = false;
        this.isSubscribed = subscriptionSucceeded;
        this.subscriptionPromiseResolver(subscriptionSucceeded);
        return subscriptionSucceeded;
    }
    async updateAccountsToPoll() {
        if (this.accountsToPoll.size > 0) {
            return;
        }
        const statePublicKey = await (0, pda_1.getDriftStateAccountPublicKey)(this.program.programId);
        this.accountsToPoll.set(statePublicKey.toString(), {
            key: 'state',
            publicKey: statePublicKey,
            eventType: 'stateAccountUpdate',
        });
        await this.updatePerpMarketAccountsToPoll();
        await this.updateSpotMarketAccountsToPoll();
    }
    async updatePerpMarketAccountsToPoll() {
        for (const marketIndex of this.perpMarketIndexes) {
            await this.addPerpMarketAccountToPoll(marketIndex);
        }
        return true;
    }
    async addPerpMarketAccountToPoll(marketIndex) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, marketIndex);
        this.accountsToPoll.set(perpMarketPublicKey.toString(), {
            key: 'perpMarket',
            publicKey: perpMarketPublicKey,
            eventType: 'perpMarketAccountUpdate',
            mapKey: marketIndex,
        });
        return true;
    }
    async updateSpotMarketAccountsToPoll() {
        for (const marketIndex of this.spotMarketIndexes) {
            await this.addSpotMarketAccountToPoll(marketIndex);
        }
        return true;
    }
    async addSpotMarketAccountToPoll(marketIndex) {
        const marketPublicKey = await (0, pda_1.getSpotMarketPublicKey)(this.program.programId, marketIndex);
        this.accountsToPoll.set(marketPublicKey.toString(), {
            key: 'spotMarket',
            publicKey: marketPublicKey,
            eventType: 'spotMarketAccountUpdate',
            mapKey: marketIndex,
        });
        return true;
    }
    updateOraclesToPoll() {
        for (const oracleInfo of this.oracleInfos) {
            if (!oracleInfo.publicKey.equals(web3_js_1.PublicKey.default)) {
                this.addOracleToPoll(oracleInfo);
            }
        }
        return true;
    }
    addOracleToPoll(oracleInfo) {
        this.oraclesToPoll.set(oracleInfo.publicKey.toString(), {
            publicKey: oracleInfo.publicKey,
            source: oracleInfo.source,
        });
        return true;
    }
    async addToAccountLoader() {
        for (const [_, accountToPoll] of this.accountsToPoll) {
            await this.addAccountToAccountLoader(accountToPoll);
        }
        for (const [_, oracleToPoll] of this.oraclesToPoll) {
            await this.addOracleToAccountLoader(oracleToPoll);
        }
        this.errorCallbackId = this.accountLoader.addErrorCallbacks((error) => {
            this.eventEmitter.emit('error', error);
        });
    }
    async addAccountToAccountLoader(accountToPoll) {
        accountToPoll.callbackId = await this.accountLoader.addAccount(accountToPoll.publicKey, (buffer, slot) => {
            if (!buffer)
                return;
            const account = this.program.account[accountToPoll.key].coder.accounts.decode((0, utils_1.capitalize)(accountToPoll.key), buffer);
            const dataAndSlot = {
                data: account,
                slot,
            };
            if (accountToPoll.mapKey != undefined) {
                this[accountToPoll.key].set(accountToPoll.mapKey, dataAndSlot);
            }
            else {
                this[accountToPoll.key] = dataAndSlot;
            }
            // @ts-ignore
            this.eventEmitter.emit(accountToPoll.eventType, account);
            this.eventEmitter.emit('update');
            if (!this.isSubscribed) {
                this.isSubscribed = this.didSubscriptionSucceed();
            }
        });
    }
    async addOracleToAccountLoader(oracleToPoll) {
        const oracleClient = this.oracleClientCache.get(oracleToPoll.source, this.program.provider.connection);
        oracleToPoll.callbackId = await this.accountLoader.addAccount(oracleToPoll.publicKey, (buffer, slot) => {
            if (!buffer)
                return;
            const oraclePriceData = oracleClient.getOraclePriceDataFromBuffer(buffer);
            const dataAndSlot = {
                data: oraclePriceData,
                slot,
            };
            this.oracles.set(oracleToPoll.publicKey.toString(), dataAndSlot);
            this.eventEmitter.emit('oraclePriceUpdate', oracleToPoll.publicKey, oraclePriceData);
            this.eventEmitter.emit('update');
        });
    }
    async fetch() {
        await this.accountLoader.load();
        for (const [_, accountToPoll] of this.accountsToPoll) {
            const { buffer, slot } = this.accountLoader.getBufferAndSlot(accountToPoll.publicKey);
            if (buffer) {
                const account = this.program.account[accountToPoll.key].coder.accounts.decode((0, utils_1.capitalize)(accountToPoll.key), buffer);
                if (accountToPoll.mapKey != undefined) {
                    this[accountToPoll.key].set(accountToPoll.mapKey, {
                        data: account,
                        slot,
                    });
                }
                else {
                    this[accountToPoll.key] = {
                        data: account,
                        slot,
                    };
                }
            }
        }
        for (const [_, oracleToPoll] of this.oraclesToPoll) {
            const { buffer, slot } = this.accountLoader.getBufferAndSlot(oracleToPoll.publicKey);
            if (buffer) {
                const oracleClient = this.oracleClientCache.get(oracleToPoll.source, this.program.provider.connection);
                const oraclePriceData = oracleClient.getOraclePriceDataFromBuffer(buffer);
                this.oracles.set(oracleToPoll.publicKey.toString(), {
                    data: oraclePriceData,
                    slot,
                });
            }
        }
    }
    didSubscriptionSucceed() {
        if (this.state)
            return true;
        return false;
    }
    async unsubscribe() {
        for (const [_, accountToPoll] of this.accountsToPoll) {
            this.accountLoader.removeAccount(accountToPoll.publicKey, accountToPoll.callbackId);
        }
        for (const [_, oracleToPoll] of this.oraclesToPoll) {
            this.accountLoader.removeAccount(oracleToPoll.publicKey, oracleToPoll.callbackId);
        }
        this.accountLoader.removeErrorCallbacks(this.errorCallbackId);
        this.errorCallbackId = undefined;
        this.accountsToPoll.clear();
        this.oraclesToPoll.clear();
        this.isSubscribed = false;
    }
    async addSpotMarket(marketIndex) {
        const marketPublicKey = await (0, pda_1.getSpotMarketPublicKey)(this.program.programId, marketIndex);
        if (this.accountsToPoll.has(marketPublicKey.toString())) {
            return true;
        }
        await this.addSpotMarketAccountToPoll(marketIndex);
        const accountToPoll = this.accountsToPoll.get(marketPublicKey.toString());
        await this.addAccountToAccountLoader(accountToPoll);
        return true;
    }
    async addPerpMarket(marketIndex) {
        const marketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, marketIndex);
        if (this.accountsToPoll.has(marketPublicKey.toString())) {
            return true;
        }
        await this.addPerpMarketAccountToPoll(marketIndex);
        const accountToPoll = this.accountsToPoll.get(marketPublicKey.toString());
        await this.addAccountToAccountLoader(accountToPoll);
        return true;
    }
    async addOracle(oracleInfo) {
        if (oracleInfo.publicKey.equals(web3_js_1.PublicKey.default) ||
            this.oraclesToPoll.has(oracleInfo.publicKey.toString())) {
            return true;
        }
        this.addOracleToPoll(oracleInfo);
        const oracleToPoll = this.oraclesToPoll.get(oracleInfo.publicKey.toString());
        await this.addOracleToAccountLoader(oracleToPoll);
        return true;
    }
    assertIsSubscribed() {
        if (!this.isSubscribed) {
            throw new types_1.NotSubscribedError('You must call `subscribe` before using this function');
        }
    }
    getStateAccountAndSlot() {
        this.assertIsSubscribed();
        return this.state;
    }
    getMarketAccountAndSlot(marketIndex) {
        return this.perpMarket.get(marketIndex);
    }
    getMarketAccountsAndSlots() {
        return Array.from(this.perpMarket.values());
    }
    getSpotMarketAccountAndSlot(marketIndex) {
        return this.spotMarket.get(marketIndex);
    }
    getSpotMarketAccountsAndSlots() {
        return Array.from(this.spotMarket.values());
    }
    getOraclePriceDataAndSlot(oraclePublicKey) {
        this.assertIsSubscribed();
        if (oraclePublicKey.equals(web3_js_1.PublicKey.default)) {
            return {
                data: quoteAssetOracleClient_1.QUOTE_ORACLE_PRICE_DATA,
                slot: 0,
            };
        }
        return this.oracles.get(oraclePublicKey.toString());
    }
}
exports.PollingDriftClientAccountSubscriber = PollingDriftClientAccountSubscriber;
