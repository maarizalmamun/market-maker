"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogParser = exports.fetchLogs = void 0;
function mapTransactionResponseToLog(transaction) {
    return {
        txSig: transaction.transaction.signatures[0],
        slot: transaction.slot,
        logs: transaction.meta.logMessages,
    };
}
async function fetchLogs(connection, programId, finality, beforeTx, untilTx, limit) {
    const signatures = await connection.getSignaturesForAddress(programId, {
        before: beforeTx,
        until: untilTx,
        limit,
    }, finality);
    const sortedSignatures = signatures.sort((a, b) => a.slot === b.slot ? 0 : a.slot < b.slot ? -1 : 1);
    const filteredSignatures = sortedSignatures.filter((signature) => !signature.err);
    if (filteredSignatures.length === 0) {
        return undefined;
    }
    const chunkedSignatures = chunk(filteredSignatures, 100);
    const config = { commitment: finality, maxSupportedTransactionVersion: 0 };
    const transactionLogs = (await Promise.all(chunkedSignatures.map(async (chunk) => {
        const transactions = await connection.getTransactions(chunk.map((confirmedSignature) => confirmedSignature.signature), 
        //@ts-ignore
        config);
        return transactions.reduce((logs, transaction) => {
            if (transaction) {
                logs.push(mapTransactionResponseToLog(transaction));
            }
            return logs;
        }, new Array());
    }))).flat();
    const earliest = filteredSignatures[0];
    const mostRecent = filteredSignatures[filteredSignatures.length - 1];
    return {
        transactionLogs: transactionLogs,
        earliestTx: earliest.signature,
        mostRecentTx: mostRecent.signature,
        earliestSlot: earliest.slot,
        mostRecentSlot: mostRecent.slot,
        mostRecentBlockTime: mostRecent.blockTime,
    };
}
exports.fetchLogs = fetchLogs;
function chunk(array, size) {
    return new Array(Math.ceil(array.length / size))
        .fill(null)
        .map((_, index) => index * size)
        .map((begin) => array.slice(begin, begin + size));
}
class LogParser {
    constructor(program) {
        this.program = program;
    }
    parseEventsFromTransaction(transaction) {
        const transactionLogObject = mapTransactionResponseToLog(transaction);
        return this.parseEventsFromLogs(transactionLogObject);
    }
    parseEventsFromLogs(event) {
        const records = [];
        // @ts-ignore
        const eventGenerator = this.program._events._eventParser.parseLogs(event.logs, false);
        for (const eventLog of eventGenerator) {
            eventLog.data.txSig = event.txSig;
            eventLog.data.slot = event.slot;
            eventLog.data.eventType = eventLog.name;
            records.push(eventLog.data);
        }
        return records;
    }
}
exports.LogParser = LogParser;
