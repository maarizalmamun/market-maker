/// <reference types="node" />
import { AnchorProvider, BN, Program, ProgramAccount } from '@coral-xyz/anchor';
import { StateAccount, IWallet, PositionDirection, UserAccount, PerpMarketAccount, OrderParams, Order, SpotMarketAccount, SpotPosition, MakerInfo, TakerInfo, OptionalOrderParams, ReferrerInfo, MarketType, TxParams, SerumV3FulfillmentConfigAccount, ReferrerNameAccount, OrderTriggerCondition, PerpMarketExtendedInfo, UserStatsAccount, ModifyOrderParams, PhoenixV1FulfillmentConfigAccount } from '@drift-labs/sdk/lib/types';
import * as anchor from '@coral-xyz/anchor';
import { Connection, PublicKey, TransactionSignature, ConfirmOptions, Transaction, TransactionInstruction, AccountMeta, Signer, AddressLookupTableAccount } from '@solana/web3.js';
import { TokenFaucet } from '@drift-labs/sdk/lib/tokenFaucet';
import { EventEmitter } from 'events';
import StrictEventEmitter from 'strict-event-emitter-types';
import { DriftClientAccountSubscriber, DriftClientAccountEvents, DataAndSlot } from '@drift-labs/sdk/lib/accounts/types';
import { TxSender, TxSigAndSlot } from '@drift-labs/sdk/lib/tx/types';
import { OraclePriceData } from '@drift-labs/sdk/lib/oracles/types';
import { DriftClientConfig } from '@drift-labs/sdk/lib/driftClientConfig';
import { User } from '@drift-labs/sdk/lib/user';
import { UserSubscriptionConfig } from '@drift-labs/sdk/lib/userConfig';
import { UserStats } from '@drift-labs/sdk/lib/userStats';
type RemainingAccountParams = {
    userAccounts: UserAccount[];
    writablePerpMarketIndexes?: number[];
    writableSpotMarketIndexes?: number[];
    readablePerpMarketIndex?: number;
    readableSpotMarketIndexes?: number[];
    useMarketLastSlotCache?: boolean;
};
/**
 * # DriftClient
 * This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more.
 */
export declare class DriftClient {
    connection: Connection;
    wallet: IWallet;
    program: Program;
    provider: AnchorProvider;
    opts?: ConfirmOptions;
    users: Map<string, User>;
    userStats?: UserStats;
    activeSubAccountId: number;
    userAccountSubscriptionConfig: UserSubscriptionConfig;
    accountSubscriber: DriftClientAccountSubscriber;
    eventEmitter: StrictEventEmitter<EventEmitter, DriftClientAccountEvents>;
    _isSubscribed: boolean;
    txSender: TxSender;
    perpMarketLastSlotCache: Map<number, number>;
    spotMarketLastSlotCache: Map<number, number>;
    authority: PublicKey;
    marketLookupTable: PublicKey;
    lookupTableAccount: AddressLookupTableAccount;
    includeDelegates?: boolean;
    authoritySubAccountMap?: Map<string, number[]>;
    skipLoadUsers?: boolean;
    get isSubscribed(): boolean;
    set isSubscribed(val: boolean);
    constructor(config: DriftClientConfig);
    getUserMapKey(subAccountId: number, authority: PublicKey): string;
    createUser(subAccountId: number, accountSubscriptionConfig: UserSubscriptionConfig, authority?: PublicKey): User;
    subscribe(): Promise<boolean>;
    subscribeUsers(): Promise<boolean>[];
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    fetchAccounts(): Promise<void>;
    unsubscribe(): Promise<void>;
    unsubscribeUsers(): Promise<void>[];
    statePublicKey?: PublicKey;
    getStatePublicKey(): Promise<PublicKey>;
    signerPublicKey?: PublicKey;
    getSignerPublicKey(): PublicKey;
    getStateAccount(): StateAccount;
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     */
    forceGetStateAccount(): Promise<StateAccount>;
    getPerpMarketAccount(marketIndex: number): PerpMarketAccount | undefined;
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    forceGetPerpMarketAccount(marketIndex: number): Promise<PerpMarketAccount | undefined>;
    getPerpMarketAccounts(): PerpMarketAccount[];
    getSpotMarketAccount(marketIndex: number): SpotMarketAccount | undefined;
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    forceGetSpotMarketAccount(marketIndex: number): Promise<SpotMarketAccount | undefined>;
    getSpotMarketAccounts(): SpotMarketAccount[];
    getQuoteSpotMarketAccount(): SpotMarketAccount;
    getOraclePriceDataAndSlot(oraclePublicKey: PublicKey): DataAndSlot<OraclePriceData> | undefined;
    getSerumV3FulfillmentConfig(serumMarket: PublicKey): Promise<SerumV3FulfillmentConfigAccount>;
    getPhoenixV1FulfillmentConfig(phoenixMarket: PublicKey): Promise<PhoenixV1FulfillmentConfigAccount>;
    fetchMarketLookupTableAccount(): Promise<AddressLookupTableAccount>;
    /**
     * Update the wallet to use for drift transactions and linked user account
     * @param newWallet
     * @param subAccountIds
     * @param activeSubAccountId
     * @param includeDelegates
     */
    updateWallet(newWallet: IWallet, subAccountIds?: number[], activeSubAccountId?: number, includeDelegates?: boolean, authoritySubaccountMap?: Map<string, number[]>): Promise<boolean>;
    switchActiveUser(subAccountId: number, authority?: PublicKey): void;
    addUser(subAccountId: number, authority?: PublicKey, userAccount?: UserAccount): Promise<boolean>;
    /**
     * Adds and subscribes to users based on params set by the constructor or by updateWallet.
     */
    addAndSubscribeToUsers(): Promise<boolean>;
    initializeUserAccount(subAccountId?: number, name?: string, referrerInfo?: ReferrerInfo): Promise<[TransactionSignature, PublicKey]>;
    getInitializeUserInstructions(subAccountId?: number, name?: string, referrerInfo?: ReferrerInfo): Promise<[PublicKey, TransactionInstruction]>;
    getInitializeUserStatsIx(): Promise<TransactionInstruction>;
    initializeReferrerName(name: string): Promise<TransactionSignature>;
    updateUserName(name: string, subAccountId?: number): Promise<TransactionSignature>;
    updateUserCustomMarginRatio(marginRatio: number, subAccountId?: number): Promise<TransactionSignature>;
    updateUserMarginTradingEnabled(marginTradingEnabled: boolean, subAccountId?: number): Promise<TransactionSignature>;
    updateUserDelegate(delegate: PublicKey, subAccountId?: number): Promise<TransactionSignature>;
    fetchAllUserAccounts(includeIdle?: boolean): Promise<ProgramAccount<UserAccount>[]>;
    getUserAccountsForDelegate(delegate: PublicKey): Promise<UserAccount[]>;
    getUserAccountsAndAddressesForAuthority(authority: PublicKey): Promise<ProgramAccount<UserAccount>[]>;
    getUserAccountsForAuthority(authority: PublicKey): Promise<UserAccount[]>;
    getReferredUserStatsAccountsByReferrer(referrer: PublicKey): Promise<UserStatsAccount[]>;
    getReferrerNameAccountsForAuthority(authority: PublicKey): Promise<ReferrerNameAccount[]>;
    deleteUser(subAccountId?: number, txParams?: TxParams): Promise<TransactionSignature>;
    getUser(subAccountId?: number, authority?: PublicKey): User;
    getUsers(): User[];
    getUserStats(): UserStats;
    fetchReferrerNameAccount(name: string): Promise<ReferrerNameAccount | undefined>;
    userStatsAccountPublicKey: PublicKey;
    getUserStatsAccountPublicKey(): PublicKey;
    getUserAccountPublicKey(subAccountId?: number, authority?: PublicKey): Promise<PublicKey>;
    getUserAccount(subAccountId?: number, authority?: PublicKey): UserAccount | undefined;
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param subAccountId
     */
    forceGetUserAccount(subAccountId?: number): Promise<UserAccount | undefined>;
    getUserAccountAndSlot(subAccountId?: number): DataAndSlot<UserAccount> | undefined;
    getSpotPosition(marketIndex: number): SpotPosition | undefined;
    getQuoteAssetTokenAmount(): BN;
    getTokenAmount(marketIndex: number): BN;
    getRemainingAccounts(params: RemainingAccountParams): AccountMeta[];
    getRemainingAccountMapsForUsers(userAccounts: UserAccount[]): {
        oracleAccountMap: Map<string, AccountMeta>;
        spotMarketAccountMap: Map<number, AccountMeta>;
        perpMarketAccountMap: Map<number, AccountMeta>;
    };
    getOrder(orderId: number): Order | undefined;
    getOrderByUserId(userOrderId: number): Order | undefined;
    deposit(amount: BN, marketIndex: number, collateralAccountPublicKey: PublicKey, subAccountId?: number, reduceOnly?: boolean): Promise<TransactionSignature>;
    getDepositInstruction(amount: BN, marketIndex: number, userTokenAccount: PublicKey, subAccountId?: number, reduceOnly?: boolean, userInitialized?: boolean): Promise<TransactionInstruction>;
    private checkIfAccountExists;
    private getWrappedSolAccountCreationIxs;
    getAssociatedTokenAccountCreationIx(tokenMintAddress: PublicKey, associatedTokenAddress: PublicKey): anchor.web3.TransactionInstruction;
    /**
     * Creates the Clearing House User account for a user, and deposits some initial collateral
     * @param amount
     * @param userTokenAccount
     * @param marketIndex
     * @param subAccountId
     * @param name
     * @param fromSubAccountId
     * @returns
     */
    initializeUserAccountAndDepositCollateral(amount: BN, userTokenAccount: PublicKey, marketIndex?: number, subAccountId?: number, name?: string, fromSubAccountId?: number, referrerInfo?: ReferrerInfo, txParams?: TxParams): Promise<[TransactionSignature, PublicKey]>;
    initializeUserAccountForDevnet(subAccountId: number, name: string, marketIndex: number, tokenFaucet: TokenFaucet, amount: BN, referrerInfo?: ReferrerInfo): Promise<[TransactionSignature, PublicKey]>;
    withdraw(amount: BN, marketIndex: number, userTokenAccount: PublicKey, reduceOnly?: boolean): Promise<TransactionSignature>;
    getWithdrawIx(amount: BN, marketIndex: number, userTokenAccount: PublicKey, reduceOnly?: boolean): Promise<TransactionInstruction>;
    transferDeposit(amount: BN, marketIndex: number, fromSubAccountId: number, toSubAccountId: number, txParams?: TxParams): Promise<TransactionSignature>;
    getTransferDepositIx(amount: BN, marketIndex: number, fromSubAccountId: number, toSubAccountId: number): Promise<TransactionInstruction>;
    updateSpotMarketCumulativeInterest(marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    updateSpotMarketCumulativeInterestIx(marketIndex: number): Promise<TransactionInstruction>;
    settleLP(settleeUserAccountPublicKey: PublicKey, marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    settleLPIx(settleeUserAccountPublicKey: PublicKey, marketIndex: number): Promise<TransactionInstruction>;
    removePerpLpShares(marketIndex: number, sharesToBurn?: BN, txParams?: TxParams): Promise<TransactionSignature>;
    removePerpLpSharesInExpiringMarket(marketIndex: number, userAccountPublicKey: PublicKey, sharesToBurn?: BN, txParams?: TxParams): Promise<TransactionSignature>;
    getRemovePerpLpSharesInExpiringMarket(marketIndex: number, userAccountPublicKey: PublicKey, sharesToBurn?: BN): Promise<TransactionInstruction>;
    getRemovePerpLpSharesIx(marketIndex: number, sharesToBurn?: BN): Promise<TransactionInstruction>;
    addPerpLpShares(amount: BN, marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    getAddPerpLpSharesIx(amount: BN, marketIndex: number): Promise<TransactionInstruction>;
    openPosition(direction: PositionDirection, amount: BN, marketIndex: number, limitPrice?: BN): Promise<TransactionSignature>;
    sendSignedTx(tx: Transaction): Promise<TransactionSignature>;
    /**
     * Sends a market order and returns a signed tx which can fill the order against the vamm, which the caller can use to fill their own order if required.
     * @param orderParams
     * @param userAccountPublicKey
     * @param userAccount
     * @param makerInfo
     * @param txParams
     * @param bracketOrdersParams
     * @returns
     */
    sendMarketOrderAndGetSignedFillTx(orderParams: OptionalOrderParams, userAccountPublicKey: PublicKey, userAccount: UserAccount, makerInfo?: MakerInfo | MakerInfo[], txParams?: TxParams, bracketOrdersParams?: OptionalOrderParams[], referrerInfo?: ReferrerInfo): Promise<{
        txSig: TransactionSignature;
        signedFillTx: Transaction;
    }>;
    placePerpOrder(orderParams: OptionalOrderParams, txParams?: TxParams): Promise<TransactionSignature>;
    getOrderParams(optionalOrderParams: OptionalOrderParams, marketType: MarketType): OrderParams;
    getPlacePerpOrderIx(orderParams: OptionalOrderParams): Promise<TransactionInstruction>;
    updateAMMs(marketIndexes: number[], txParams?: TxParams): Promise<TransactionSignature>;
    getUpdateAMMsIx(marketIndexes: number[]): Promise<TransactionInstruction>;
    settleExpiredMarket(marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    getSettleExpiredMarketIx(marketIndex: number): Promise<TransactionInstruction>;
    settleExpiredMarketPoolsToRevenuePool(perpMarketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    cancelOrder(orderId?: number, txParams?: TxParams): Promise<TransactionSignature>;
    getCancelOrderIx(orderId?: number): Promise<TransactionInstruction>;
    cancelOrderByUserId(userOrderId: number, txParams?: TxParams): Promise<TransactionSignature>;
    getCancelOrderByUserIdIx(userOrderId: number): Promise<TransactionInstruction>;
    cancelOrders(marketType?: MarketType, marketIndex?: number, direction?: PositionDirection, txParams?: TxParams): Promise<TransactionSignature>;
    getCancelOrdersIx(marketType: MarketType | null, marketIndex: number | null, direction: PositionDirection | null): Promise<TransactionInstruction>;
    cancelAndPlaceOrders(cancelOrderParams: {
        marketType?: MarketType;
        marketIndex?: number;
        direction?: PositionDirection;
    }, placeOrderParams: OrderParams[], txParams?: TxParams): Promise<TransactionSignature>;
    fillPerpOrder(userAccountPublicKey: PublicKey, user: UserAccount, order?: Pick<Order, 'marketIndex' | 'orderId'>, makerInfo?: MakerInfo | MakerInfo[], referrerInfo?: ReferrerInfo, txParams?: TxParams): Promise<TransactionSignature>;
    getFillPerpOrderIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, order: Pick<Order, 'marketIndex' | 'orderId'>, makerInfo?: MakerInfo | MakerInfo[], referrerInfo?: ReferrerInfo): Promise<TransactionInstruction>;
    getRevertFillIx(): Promise<TransactionInstruction>;
    placeSpotOrder(orderParams: OptionalOrderParams, txParams?: TxParams): Promise<TransactionSignature>;
    getPlaceSpotOrderIx(orderParams: OptionalOrderParams): Promise<TransactionInstruction>;
    fillSpotOrder(userAccountPublicKey: PublicKey, user: UserAccount, order?: Order, fulfillmentConfig?: SerumV3FulfillmentConfigAccount | PhoenixV1FulfillmentConfigAccount, makerInfo?: MakerInfo, referrerInfo?: ReferrerInfo, txParams?: TxParams): Promise<TransactionSignature>;
    getFillSpotOrderIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, order?: Order, fulfillmentConfig?: SerumV3FulfillmentConfigAccount | PhoenixV1FulfillmentConfigAccount, makerInfo?: MakerInfo, referrerInfo?: ReferrerInfo): Promise<TransactionInstruction>;
    addSpotFulfillmentAccounts(marketIndex: number, remainingAccounts: AccountMeta[], fulfillmentConfig?: SerumV3FulfillmentConfigAccount | PhoenixV1FulfillmentConfigAccount): void;
    addSerumRemainingAccounts(marketIndex: number, remainingAccounts: AccountMeta[], fulfillmentConfig: SerumV3FulfillmentConfigAccount): void;
    addPhoenixRemainingAccounts(marketIndex: number, remainingAccounts: AccountMeta[], fulfillmentConfig: PhoenixV1FulfillmentConfigAccount): void;
    triggerOrder(userAccountPublicKey: PublicKey, user: UserAccount, order: Order, txParams?: TxParams): Promise<TransactionSignature>;
    getTriggerOrderIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, order: Order): Promise<TransactionInstruction>;
    forceCancelOrders(userAccountPublicKey: PublicKey, user: UserAccount, txParams?: TxParams): Promise<TransactionSignature>;
    getForceCancelOrdersIx(userAccountPublicKey: PublicKey, userAccount: UserAccount): Promise<TransactionInstruction>;
    updateUserIdle(userAccountPublicKey: PublicKey, user: UserAccount, txParams?: TxParams): Promise<TransactionSignature>;
    getUpdateUserIdleIx(userAccountPublicKey: PublicKey, userAccount: UserAccount): Promise<TransactionInstruction>;
    placeAndTakePerpOrder(orderParams: OptionalOrderParams, makerInfo?: MakerInfo | MakerInfo[], referrerInfo?: ReferrerInfo, txParams?: TxParams): Promise<TransactionSignature>;
    getPlaceAndTakePerpOrderIx(orderParams: OptionalOrderParams, makerInfo?: MakerInfo | MakerInfo[], referrerInfo?: ReferrerInfo): Promise<TransactionInstruction>;
    placeAndMakePerpOrder(orderParams: OptionalOrderParams, takerInfo: TakerInfo, referrerInfo?: ReferrerInfo, txParams?: TxParams): Promise<TransactionSignature>;
    getPlaceAndMakePerpOrderIx(orderParams: OptionalOrderParams, takerInfo: TakerInfo, referrerInfo?: ReferrerInfo): Promise<TransactionInstruction>;
    placeAndTakeSpotOrder(orderParams: OptionalOrderParams, fulfillmentConfig?: SerumV3FulfillmentConfigAccount, makerInfo?: MakerInfo, referrerInfo?: ReferrerInfo, txParams?: TxParams): Promise<TransactionSignature>;
    getPlaceAndTakeSpotOrderIx(orderParams: OptionalOrderParams, fulfillmentConfig?: SerumV3FulfillmentConfigAccount, makerInfo?: MakerInfo, referrerInfo?: ReferrerInfo): Promise<TransactionInstruction>;
    placeAndMakeSpotOrder(orderParams: OptionalOrderParams, takerInfo: TakerInfo, fulfillmentConfig?: SerumV3FulfillmentConfigAccount, referrerInfo?: ReferrerInfo, txParams?: TxParams): Promise<TransactionSignature>;
    getPlaceAndMakeSpotOrderIx(orderParams: OptionalOrderParams, takerInfo: TakerInfo, fulfillmentConfig?: SerumV3FulfillmentConfigAccount, referrerInfo?: ReferrerInfo): Promise<TransactionInstruction>;
    /**
     * Close an entire position. If you want to reduce a position, use the {@link openPosition} method in the opposite direction of the current position.
     * @param marketIndex
     * @returns
     */
    closePosition(marketIndex: number, limitPrice?: BN): Promise<TransactionSignature>;
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrder instead
     * @param orderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    modifyPerpOrder(orderId: number, newBaseAmount?: BN, newLimitPrice?: BN, newOraclePriceOffset?: number): Promise<TransactionSignature>;
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrderByUserOrderId instead
     * @param userOrderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    modifyPerpOrderByUserOrderId(userOrderId: number, newBaseAmount?: BN, newLimitPrice?: BN, newOraclePriceOffset?: number): Promise<TransactionSignature>;
    /**
     * Modifies an open order (spot or perp) by closing it and replacing it with a new order.
     * @param orderId: The open order to modify
     * @param newDirection: The new direction for the order
     * @param newBaseAmount: The new base amount for the order
     * @param newLimitPice: The new limit price for the order
     * @param newOraclePriceOffset: The new oracle price offset for the order
     * @param newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param auctionDuration:
     * @param auctionStartPrice:
     * @param auctionEndPrice:
     * @param reduceOnly:
     * @param postOnly:
     * @param immediateOrCancel:
     * @param maxTs:
     * @returns
     */
    modifyOrder({ orderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, txParams, }: {
        orderId: number;
        newDirection?: PositionDirection;
        newBaseAmount?: BN;
        newLimitPrice?: BN;
        newOraclePriceOffset?: number;
        newTriggerPrice?: BN;
        newTriggerCondition?: OrderTriggerCondition;
        auctionDuration?: number;
        auctionStartPrice?: BN;
        auctionEndPrice?: BN;
        reduceOnly?: boolean;
        postOnly?: boolean;
        immediateOrCancel?: boolean;
        maxTs?: BN;
        txParams?: TxParams;
    }): Promise<TransactionSignature>;
    getModifyOrderIx(orderId: number, orderParams: ModifyOrderParams): Promise<TransactionInstruction>;
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @param userOrderId: The open order to modify
     * @param newDirection: The new direction for the order
     * @param newBaseAmount: The new base amount for the order
     * @param newLimitPice: The new limit price for the order
     * @param newOraclePriceOffset: The new oracle price offset for the order
     * @param newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param auctionDuration: Only required if order type changed to market from something else
     * @param auctionStartPrice: Only required if order type changed to market from something else
     * @param auctionEndPrice: Only required if order type changed to market from something else
     * @param reduceOnly:
     * @param postOnly:
     * @param immediateOrCancel:
     * @param maxTs:
     * @returns
     */
    modifyOrderByUserOrderId({ userOrderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, txParams, }: {
        userOrderId: number;
        newDirection?: PositionDirection;
        newBaseAmount?: BN;
        newLimitPrice?: BN;
        newOraclePriceOffset?: number;
        newTriggerPrice?: BN;
        newTriggerCondition?: OrderTriggerCondition;
        auctionDuration?: number;
        auctionStartPrice?: BN;
        auctionEndPrice?: BN;
        reduceOnly?: boolean;
        postOnly?: boolean;
        immediateOrCancel?: boolean;
        maxTs?: BN;
        txParams?: TxParams;
    }): Promise<TransactionSignature>;
    getModifyOrderByUserIdIx(userOrderId: number, orderParams: ModifyOrderParams): Promise<TransactionInstruction>;
    settlePNLs(users: {
        settleeUserAccountPublicKey: PublicKey;
        settleeUserAccount: UserAccount;
    }[], marketIndexes: number[]): Promise<TransactionSignature>;
    settlePNL(settleeUserAccountPublicKey: PublicKey, settleeUserAccount: UserAccount, marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    settlePNLIx(settleeUserAccountPublicKey: PublicKey, settleeUserAccount: UserAccount, marketIndex: number): Promise<TransactionInstruction>;
    liquidatePerp(userAccountPublicKey: PublicKey, userAccount: UserAccount, marketIndex: number, maxBaseAssetAmount: BN, limitPrice?: BN, txParams?: TxParams): Promise<TransactionSignature>;
    getLiquidatePerpIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, marketIndex: number, maxBaseAssetAmount: BN, limitPrice?: BN): Promise<TransactionInstruction>;
    liquidateSpot(userAccountPublicKey: PublicKey, userAccount: UserAccount, assetMarketIndex: number, liabilityMarketIndex: number, maxLiabilityTransfer: BN, limitPrice?: BN, txParams?: TxParams): Promise<TransactionSignature>;
    getLiquidateSpotIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, assetMarketIndex: number, liabilityMarketIndex: number, maxLiabilityTransfer: BN, limitPrice?: BN): Promise<TransactionInstruction>;
    liquidateBorrowForPerpPnl(userAccountPublicKey: PublicKey, userAccount: UserAccount, perpMarketIndex: number, liabilityMarketIndex: number, maxLiabilityTransfer: BN, limitPrice?: BN, txParams?: TxParams): Promise<TransactionSignature>;
    getLiquidateBorrowForPerpPnlIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, perpMarketIndex: number, liabilityMarketIndex: number, maxLiabilityTransfer: BN, limitPrice?: BN): Promise<TransactionInstruction>;
    liquidatePerpPnlForDeposit(userAccountPublicKey: PublicKey, userAccount: UserAccount, perpMarketIndex: number, assetMarketIndex: number, maxPnlTransfer: BN, limitPrice?: BN, txParams?: TxParams): Promise<TransactionSignature>;
    getLiquidatePerpPnlForDepositIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, perpMarketIndex: number, assetMarketIndex: number, maxPnlTransfer: BN, limitPrice?: BN): Promise<TransactionInstruction>;
    resolvePerpBankruptcy(userAccountPublicKey: PublicKey, userAccount: UserAccount, marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    getResolvePerpBankruptcyIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, marketIndex: number): Promise<TransactionInstruction>;
    resolveSpotBankruptcy(userAccountPublicKey: PublicKey, userAccount: UserAccount, marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    getResolveSpotBankruptcyIx(userAccountPublicKey: PublicKey, userAccount: UserAccount, marketIndex: number): Promise<TransactionInstruction>;
    updateFundingRate(perpMarketIndex: number, oracle: PublicKey, txParams?: TxParams): Promise<TransactionSignature>;
    getUpdateFundingRateIx(perpMarketIndex: number, oracle: PublicKey): Promise<TransactionInstruction>;
    settleFundingPayment(userAccountPublicKey: PublicKey, txParams?: TxParams): Promise<TransactionSignature>;
    getSettleFundingPaymentIx(userAccountPublicKey: PublicKey): Promise<TransactionInstruction>;
    triggerEvent(eventName: keyof DriftClientAccountEvents, data?: any): void;
    getOracleDataForPerpMarket(marketIndex: number): OraclePriceData;
    getOracleDataForSpotMarket(marketIndex: number): OraclePriceData;
    initializeInsuranceFundStake(marketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    getInitializeInsuranceFundStakeIx(marketIndex: number): Promise<TransactionInstruction>;
    getAddInsuranceFundStakeIx(marketIndex: number, amount: BN, collateralAccountPublicKey: PublicKey): Promise<TransactionInstruction>;
    /**
     * Add to an insurance fund stake and optionally initialize the account
     */
    addInsuranceFundStake({ marketIndex, amount, collateralAccountPublicKey, initializeStakeAccount, fromSubaccount, }: {
        /**
         * Spot market index
         */
        marketIndex: number;
        amount: BN;
        /**
         * The account where the funds to stake come from. Usually an associated token account
         */
        collateralAccountPublicKey: PublicKey;
        /**
         * Add instructions to initialize the staking account -- required if its the first time the currrent authority has staked in this market
         */
        initializeStakeAccount?: boolean;
        /**
         * Optional -- withdraw from current subaccount to fund stake amount, instead of wallet balance
         */
        fromSubaccount?: boolean;
    }): Promise<TransactionSignature>;
    requestRemoveInsuranceFundStake(marketIndex: number, amount: BN): Promise<TransactionSignature>;
    cancelRequestRemoveInsuranceFundStake(marketIndex: number): Promise<TransactionSignature>;
    removeInsuranceFundStake(marketIndex: number, collateralAccountPublicKey: PublicKey): Promise<TransactionSignature>;
    settleRevenueToInsuranceFund(marketIndex: number): Promise<TransactionSignature>;
    resolvePerpPnlDeficit(spotMarketIndex: number, perpMarketIndex: number, txParams?: TxParams): Promise<TransactionSignature>;
    getResolvePerpPnlDeficitIx(spotMarketIndex: number, perpMarketIndex: number): Promise<TransactionInstruction>;
    getPerpMarketExtendedInfo(marketIndex: number): PerpMarketExtendedInfo;
    /**
     * Returns the market index and type for a given market name
     * E.g. "SOL-PERP" -> { marketIndex: 0, marketType: MarketType.PERP }
     *
     * @param name
     */
    getMarketIndexAndType(name: string): {
        marketIndex: number;
        marketType: MarketType;
    } | undefined;
    sendTransaction(tx: Transaction, additionalSigners?: Array<Signer>, opts?: ConfirmOptions, preSigned?: boolean): Promise<TxSigAndSlot>;
}
export {};
