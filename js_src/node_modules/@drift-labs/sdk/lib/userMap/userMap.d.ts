import { User, DriftClient, UserAccount, OrderRecord, UserSubscriptionConfig, WrappedEvent, DLOB } from '@drift-labs/sdk';
import { PublicKey } from '@solana/web3.js';
export interface UserMapInterface {
    subscribe(): Promise<void>;
    unsubscribe(): Promise<void>;
    addPubkey(userAccountPublicKey: PublicKey): Promise<void>;
    has(key: string): boolean;
    get(key: string): User | undefined;
    mustGet(key: string): Promise<User>;
    getUserAuthority(key: string): PublicKey | undefined;
    updateWithOrderRecord(record: OrderRecord): Promise<void>;
    values(): IterableIterator<User>;
}
export declare class UserMap implements UserMapInterface {
    private userMap;
    private driftClient;
    private accountSubscription;
    private includeIdle;
    private lastNumberOfSubAccounts;
    private syncCallback;
    constructor(driftClient: DriftClient, accountSubscription: UserSubscriptionConfig, includeIdle?: boolean);
    subscribe(): Promise<void>;
    addPubkey(userAccountPublicKey: PublicKey, userAccount?: UserAccount): Promise<void>;
    has(key: string): boolean;
    /**
     * gets the User for a particular userAccountPublicKey, if no User exists, undefined is returned
     * @param key userAccountPublicKey to get User for
     * @returns user User | undefined
     */
    get(key: string): User | undefined;
    /**
     * gets the User for a particular userAccountPublicKey, if no User exists, new one is created
     * @param key userAccountPublicKey to get User for
     * @returns  User
     */
    mustGet(key: string): Promise<User>;
    /**
     * gets the Authority for a particular userAccountPublicKey, if no User exists, undefined is returned
     * @param key userAccountPublicKey to get User for
     * @returns authority PublicKey | undefined
     */
    getUserAuthority(key: string): PublicKey | undefined;
    /**
     * implements the {@link DLOBSource} interface
     * create a DLOB from all the subscribed users
     * @param slot
     */
    getDLOB(slot: number): Promise<DLOB>;
    updateWithOrderRecord(record: OrderRecord): Promise<void>;
    updateWithEventRecord(record: WrappedEvent<any>): Promise<void>;
    values(): IterableIterator<User>;
    size(): number;
    sync(): Promise<void>;
    unsubscribe(): Promise<void>;
}
