"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserMap = void 0;
const __1 = require("..");
const web3_js_1 = require("@solana/web3.js");
const buffer_1 = require("buffer");
const bs58_1 = __importDefault(require("bs58"));
class UserMap {
    constructor(driftClient, accountSubscription, includeIdle = true) {
        this.userMap = new Map();
        this.syncCallback = async (state) => {
            if (state.numberOfSubAccounts !== this.lastNumberOfSubAccounts) {
                await this.sync();
                this.lastNumberOfSubAccounts = state.numberOfSubAccounts;
            }
        };
        this.driftClient = driftClient;
        this.accountSubscription = accountSubscription;
        this.includeIdle = includeIdle;
    }
    async subscribe() {
        if (this.size() > 0) {
            return;
        }
        await this.driftClient.subscribe();
        this.lastNumberOfSubAccounts =
            this.driftClient.getStateAccount().numberOfSubAccounts;
        this.driftClient.eventEmitter.on('stateAccountUpdate', this.syncCallback);
        await this.sync();
    }
    async addPubkey(userAccountPublicKey, userAccount) {
        const user = new __1.User({
            driftClient: this.driftClient,
            userAccountPublicKey,
            accountSubscription: this.accountSubscription,
        });
        await user.subscribe(userAccount);
        this.userMap.set(userAccountPublicKey.toString(), user);
    }
    has(key) {
        return this.userMap.has(key);
    }
    /**
     * gets the User for a particular userAccountPublicKey, if no User exists, undefined is returned
     * @param key userAccountPublicKey to get User for
     * @returns user User | undefined
     */
    get(key) {
        return this.userMap.get(key);
    }
    /**
     * gets the User for a particular userAccountPublicKey, if no User exists, new one is created
     * @param key userAccountPublicKey to get User for
     * @returns  User
     */
    async mustGet(key) {
        if (!this.has(key)) {
            await this.addPubkey(new web3_js_1.PublicKey(key));
        }
        const user = this.userMap.get(key);
        return user;
    }
    /**
     * gets the Authority for a particular userAccountPublicKey, if no User exists, undefined is returned
     * @param key userAccountPublicKey to get User for
     * @returns authority PublicKey | undefined
     */
    getUserAuthority(key) {
        const chUser = this.userMap.get(key);
        if (!chUser) {
            return undefined;
        }
        return chUser.getUserAccount().authority;
    }
    /**
     * implements the {@link DLOBSource} interface
     * create a DLOB from all the subscribed users
     * @param slot
     */
    async getDLOB(slot) {
        const dlob = new __1.DLOB();
        await dlob.initFromUserMap(this, slot);
        return dlob;
    }
    async updateWithOrderRecord(record) {
        if (!this.has(record.user.toString())) {
            await this.addPubkey(record.user);
        }
    }
    async updateWithEventRecord(record) {
        if (record.eventType === 'DepositRecord') {
            const depositRecord = record;
            await this.mustGet(depositRecord.user.toString());
        }
        else if (record.eventType === 'FundingPaymentRecord') {
            const fundingPaymentRecord = record;
            await this.mustGet(fundingPaymentRecord.user.toString());
        }
        else if (record.eventType === 'LiquidationRecord') {
            const liqRecord = record;
            await this.mustGet(liqRecord.user.toString());
            await this.mustGet(liqRecord.liquidator.toString());
        }
        else if (record.eventType === 'OrderRecord') {
            const orderRecord = record;
            await this.updateWithOrderRecord(orderRecord);
        }
        else if (record.eventType === 'OrderActionRecord') {
            const actionRecord = record;
            if (actionRecord.taker) {
                await this.mustGet(actionRecord.taker.toString());
            }
            if (actionRecord.maker) {
                await this.mustGet(actionRecord.maker.toString());
            }
        }
        else if (record.eventType === 'SettlePnlRecord') {
            const settlePnlRecord = record;
            await this.mustGet(settlePnlRecord.user.toString());
        }
        else if (record.eventType === 'NewUserRecord') {
            const newUserRecord = record;
            await this.mustGet(newUserRecord.user.toString());
        }
        else if (record.eventType === 'LPRecord') {
            const lpRecord = record;
            await this.mustGet(lpRecord.user.toString());
        }
    }
    values() {
        return this.userMap.values();
    }
    size() {
        return this.userMap.size;
    }
    async sync() {
        let filters = undefined;
        if (!this.includeIdle) {
            filters = [
                {
                    memcmp: {
                        offset: 4350,
                        bytes: bs58_1.default.encode(Uint8Array.from([0])),
                    },
                },
            ];
        }
        const rpcRequestArgs = [
            this.driftClient.program.programId.toBase58(),
            {
                commitment: this.driftClient.connection.commitment,
                filters: [
                    {
                        memcmp: this.driftClient.program.coder.accounts.memcmp('User'),
                    },
                    ...(Array.isArray(filters) ? filters : []),
                ],
                encoding: 'base64',
                withContext: true,
            },
        ];
        // @ts-ignore
        const rpcJSONResponse = await this.driftClient.connection._rpcRequest('getProgramAccounts', rpcRequestArgs);
        const rpcResponseAndContext = rpcJSONResponse.result;
        const slot = rpcResponseAndContext.context.slot;
        const programAccountBufferMap = new Map();
        for (const programAccount of rpcResponseAndContext.value) {
            programAccountBufferMap.set(programAccount.pubkey.toString(), 
            // @ts-ignore
            buffer_1.Buffer.from(programAccount.account.data[0], programAccount.account.data[1]));
        }
        for (const [key, buffer] of programAccountBufferMap.entries()) {
            if (!this.has(key)) {
                const userAccount = this.driftClient.program.account.user.coder.accounts.decode('User', buffer);
                await this.addPubkey(new web3_js_1.PublicKey(key), userAccount);
            }
        }
        for (const [key, user] of this.userMap.entries()) {
            if (!programAccountBufferMap.has(key)) {
                await user.unsubscribe();
                this.userMap.delete(key);
            }
            else {
                const userAccount = this.driftClient.program.account.user.coder.accounts.decode('User', programAccountBufferMap.get(key));
                user.accountSubscriber.updateData(userAccount, slot);
            }
        }
    }
    async unsubscribe() {
        for (const [key, user] of this.userMap.entries()) {
            await user.unsubscribe();
            this.userMap.delete(key);
        }
        if (this.lastNumberOfSubAccounts) {
            this.driftClient.eventEmitter.removeListener('stateAccountUpdate', this.syncCallback);
            this.lastNumberOfSubAccounts = undefined;
        }
    }
}
exports.UserMap = UserMap;
