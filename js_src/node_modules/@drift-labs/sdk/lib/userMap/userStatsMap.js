"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserStatsMap = void 0;
const __1 = require("..");
const web3_js_1 = require("@solana/web3.js");
class UserStatsMap {
    constructor(driftClient, accountSubscription) {
        /**
         * map from authority pubkey to UserStats
         */
        this.userStatsMap = new Map();
        this.syncCallback = async (state) => {
            if (state.numberOfAuthorities !== this.lastNumberOfAuthorities) {
                await this.sync();
                this.lastNumberOfAuthorities = state.numberOfAuthorities;
            }
        };
        this.driftClient = driftClient;
        this.accountSubscription = accountSubscription;
    }
    async subscribe() {
        if (this.size() > 0) {
            return;
        }
        await this.driftClient.subscribe();
        this.lastNumberOfAuthorities =
            this.driftClient.getStateAccount().numberOfAuthorities;
        this.driftClient.eventEmitter.on('stateAccountUpdate', this.syncCallback);
        await this.sync();
    }
    async addUserStat(authority, userStatsAccount) {
        const userStat = new __1.UserStats({
            driftClient: this.driftClient,
            userStatsAccountPublicKey: (0, __1.getUserStatsAccountPublicKey)(this.driftClient.program.programId, authority),
            accountSubscription: this.accountSubscription,
        });
        await userStat.subscribe(userStatsAccount);
        this.userStatsMap.set(authority.toString(), userStat);
    }
    async updateWithOrderRecord(record, userMap) {
        const user = await userMap.mustGet(record.user.toString());
        if (!this.has(user.getUserAccount().authority.toString())) {
            await this.addUserStat(user.getUserAccount().authority);
        }
    }
    async updateWithEventRecord(record, userMap) {
        if (record.eventType === 'DepositRecord') {
            const depositRecord = record;
            await this.mustGet(depositRecord.userAuthority.toString());
        }
        else if (record.eventType === 'FundingPaymentRecord') {
            const fundingPaymentRecord = record;
            await this.mustGet(fundingPaymentRecord.userAuthority.toString());
        }
        else if (record.eventType === 'LiquidationRecord') {
            if (!userMap) {
                return;
            }
            const liqRecord = record;
            const user = await userMap.mustGet(liqRecord.user.toString());
            await this.mustGet(user.getUserAccount().authority.toString());
            const liquidatorUser = await userMap.mustGet(liqRecord.liquidator.toString());
            await this.mustGet(liquidatorUser.getUserAccount().authority.toString());
        }
        else if (record.eventType === 'OrderRecord') {
            if (!userMap) {
                return;
            }
            const orderRecord = record;
            await userMap.updateWithOrderRecord(orderRecord);
        }
        else if (record.eventType === 'OrderActionRecord') {
            if (!userMap) {
                return;
            }
            const actionRecord = record;
            if (actionRecord.taker) {
                const taker = await userMap.mustGet(actionRecord.taker.toString());
                await this.mustGet(taker.getUserAccount().authority.toString());
            }
            if (actionRecord.maker) {
                const maker = await userMap.mustGet(actionRecord.maker.toString());
                await this.mustGet(maker.getUserAccount().authority.toString());
            }
        }
        else if (record.eventType === 'SettlePnlRecord') {
            if (!userMap) {
                return;
            }
            const settlePnlRecord = record;
            const user = await userMap.mustGet(settlePnlRecord.user.toString());
            await this.mustGet(user.getUserAccount().authority.toString());
        }
        else if (record.eventType === 'NewUserRecord') {
            const newUserRecord = record;
            await this.mustGet(newUserRecord.userAuthority.toString());
        }
        else if (record.eventType === 'LPRecord') {
            if (!userMap) {
                return;
            }
            const lpRecord = record;
            const user = await userMap.mustGet(lpRecord.user.toString());
            await this.mustGet(user.getUserAccount().authority.toString());
        }
        else if (record.eventType === 'InsuranceFundStakeRecord') {
            const ifStakeRecord = record;
            await this.mustGet(ifStakeRecord.userAuthority.toString());
        }
    }
    has(authorityPublicKey) {
        return this.userStatsMap.has(authorityPublicKey);
    }
    get(authorityPublicKey) {
        return this.userStatsMap.get(authorityPublicKey);
    }
    async mustGet(authorityPublicKey) {
        if (!this.has(authorityPublicKey)) {
            await this.addUserStat(new web3_js_1.PublicKey(authorityPublicKey));
        }
        return this.get(authorityPublicKey);
    }
    values() {
        return this.userStatsMap.values();
    }
    size() {
        return this.userStatsMap.size;
    }
    async sync() {
        const programAccounts = await this.driftClient.connection.getProgramAccounts(this.driftClient.program.programId, {
            commitment: this.driftClient.connection.commitment,
            filters: [
                {
                    memcmp: this.driftClient.program.coder.accounts.memcmp('UserStats'),
                },
            ],
        });
        const programAccountMap = new Map();
        for (const programAccount of programAccounts) {
            programAccountMap.set(new web3_js_1.PublicKey(programAccount.account.data.slice(8, 40)).toString(), programAccount.account);
        }
        for (const key of programAccountMap.keys()) {
            if (!this.has(key)) {
                const userStatsAccount = this.driftClient.program.account.userStats.coder.accounts.decode('UserStats', programAccountMap.get(key).data);
                await this.addUserStat(new web3_js_1.PublicKey(key), userStatsAccount);
            }
        }
    }
    async unsubscribe() {
        for (const [key, userStats] of this.userStatsMap.entries()) {
            await userStats.unsubscribe();
            this.userStatsMap.delete(key);
        }
        if (this.lastNumberOfAuthorities) {
            this.driftClient.eventEmitter.removeListener('stateAccountUpdate', this.syncCallback);
            this.lastNumberOfAuthorities = undefined;
        }
    }
}
exports.UserStatsMap = UserStatsMap;
