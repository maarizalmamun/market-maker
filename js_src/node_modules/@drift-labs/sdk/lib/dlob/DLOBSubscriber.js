"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DLOBSubscriber = void 0;
const DLOB_1 = require("./DLOB");
const events_1 = require("events");
const types_1 = require("../types");
const orderBookLevels_1 = require("./orderBookLevels");
const market_1 = require("../math/market");
class DLOBSubscriber {
    constructor(config) {
        this.dlob = new DLOB_1.DLOB();
        this.driftClient = config.driftClient;
        this.dlobSource = config.dlobSource;
        this.slotSource = config.slotSource;
        this.updateFrequency = config.updateFrequency;
        this.eventEmitter = new events_1.EventEmitter();
    }
    async subscribe() {
        if (this.intervalId) {
            return;
        }
        await this.updateDLOB();
        this.intervalId = setInterval(async () => {
            try {
                await this.updateDLOB();
                this.eventEmitter.emit('update', this.dlob);
            }
            catch (e) {
                this.eventEmitter.emit('error', e);
            }
        }, this.updateFrequency);
    }
    async updateDLOB() {
        this.dlob = await this.dlobSource.getDLOB(this.slotSource.getSlot());
    }
    getDLOB() {
        return this.dlob;
    }
    /**
     * Get the L2 order book for a given market.
     *
     * @param marketName e.g. "SOL-PERP" or "SOL". If not provided, marketIndex and marketType must be provided.
     * @param marketIndex
     * @param marketType
     * @param depth Number of orders to include in the order book. Defaults to 10.
     * @param includeVamm Whether to include the VAMM orders in the order book. Defaults to false. If true, creates vAMM generator {@link getVammL2Generator} and adds it to fallbackL2Generators.
     * @param fallbackL2Generators L2 generators for fallback liquidity e.g. vAMM {@link getVammL2Generator}, openbook {@link SerumSubscriber}
     */
    getL2({ marketName, marketIndex, marketType, depth = 10, includeVamm = false, fallbackL2Generators = [], }) {
        if (marketName) {
            const derivedMarketInfo = this.driftClient.getMarketIndexAndType(marketName);
            if (!derivedMarketInfo) {
                throw new Error(`Market ${marketName} not found`);
            }
            marketIndex = derivedMarketInfo.marketIndex;
            marketType = derivedMarketInfo.marketType;
        }
        else {
            if (marketIndex === undefined || marketType === undefined) {
                throw new Error('Either marketName or marketIndex and marketType must be provided');
            }
        }
        let oraclePriceData;
        let fallbackBid;
        let fallbackAsk;
        const isPerp = (0, types_1.isVariant)(marketType, 'perp');
        if (isPerp) {
            const perpMarketAccount = this.driftClient.getPerpMarketAccount(marketIndex);
            oraclePriceData = this.driftClient.getOraclePriceDataAndSlot(perpMarketAccount.amm.oracle);
            fallbackBid = (0, market_1.calculateBidPrice)(perpMarketAccount, oraclePriceData);
            fallbackAsk = (0, market_1.calculateAskPrice)(perpMarketAccount, oraclePriceData);
        }
        else {
            oraclePriceData =
                this.driftClient.getOracleDataForSpotMarket(marketIndex);
        }
        if (isPerp && includeVamm) {
            fallbackL2Generators = [
                (0, orderBookLevels_1.getVammL2Generator)({
                    marketAccount: this.driftClient.getPerpMarketAccount(marketIndex),
                    oraclePriceData,
                    numOrders: depth,
                }),
            ];
        }
        return this.dlob.getL2({
            marketIndex,
            marketType,
            depth,
            oraclePriceData,
            slot: this.slotSource.getSlot(),
            fallbackBid,
            fallbackAsk,
            fallbackL2Generators: fallbackL2Generators,
        });
    }
    /**
     * Get the L3 order book for a given market.
     *
     * @param marketName e.g. "SOL-PERP" or "SOL". If not provided, marketIndex and marketType must be provided.
     * @param marketIndex
     * @param marketType
     */
    getL3({ marketName, marketIndex, marketType, }) {
        if (marketName) {
            const derivedMarketInfo = this.driftClient.getMarketIndexAndType(marketName);
            if (!derivedMarketInfo) {
                throw new Error(`Market ${marketName} not found`);
            }
            marketIndex = derivedMarketInfo.marketIndex;
            marketType = derivedMarketInfo.marketType;
        }
        else {
            if (marketIndex === undefined || marketType === undefined) {
                throw new Error('Either marketName or marketIndex and marketType must be provided');
            }
        }
        let oraclePriceData;
        const isPerp = (0, types_1.isVariant)(marketType, 'perp');
        if (isPerp) {
            oraclePriceData =
                this.driftClient.getOracleDataForPerpMarket(marketIndex);
        }
        else {
            oraclePriceData =
                this.driftClient.getOracleDataForSpotMarket(marketIndex);
        }
        return this.dlob.getL3({
            marketIndex,
            marketType,
            oraclePriceData,
            slot: this.slotSource.getSlot(),
        });
    }
    async unsubscribe() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = undefined;
        }
    }
}
exports.DLOBSubscriber = DLOBSubscriber;
