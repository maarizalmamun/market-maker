"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DLOB = void 0;
const NodeList_1 = require("./NodeList");
const __1 = require("..");
const exchangeStatus_1 = require("../math/exchangeStatus");
const orderBookLevels_1 = require("./orderBookLevels");
const SUPPORTED_ORDER_TYPES = [
    'market',
    'limit',
    'triggerMarket',
    'triggerLimit',
    'oracle',
];
class DLOB {
    constructor() {
        this.openOrders = new Map();
        this.orderLists = new Map();
        this.maxSlotForRestingLimitOrders = 0;
        this.initialized = false;
        this.init();
    }
    init() {
        this.openOrders.set('perp', new Set());
        this.openOrders.set('spot', new Set());
        this.orderLists.set('perp', new Map());
        this.orderLists.set('spot', new Map());
    }
    clear() {
        for (const marketType of this.openOrders.keys()) {
            this.openOrders.get(marketType).clear();
        }
        this.openOrders.clear();
        for (const marketType of this.orderLists.keys()) {
            for (const marketIndex of this.orderLists.get(marketType).keys()) {
                const marketNodeLists = this.orderLists
                    .get(marketType)
                    .get(marketIndex);
                for (const side of Object.keys(marketNodeLists)) {
                    for (const orderType of Object.keys(marketNodeLists[side])) {
                        marketNodeLists[side][orderType].clear();
                    }
                }
            }
        }
        this.orderLists.clear();
        this.maxSlotForRestingLimitOrders = 0;
        this.init();
    }
    /**
     * initializes a new DLOB instance
     *
     * @returns a promise that resolves when the DLOB is initialized
     */
    async initFromUserMap(userMap, slot) {
        if (this.initialized) {
            return false;
        }
        // initialize the dlob with the user map
        for (const user of userMap.values()) {
            const userAccount = user.getUserAccount();
            const userAccountPubkey = user.getUserAccountPublicKey();
            for (const order of userAccount.orders) {
                this.insertOrder(order, userAccountPubkey, slot);
            }
        }
        this.initialized = true;
        return true;
    }
    initFromOrders(dlobOrders, slot) {
        if (this.initialized) {
            return false;
        }
        for (const { user, order } of dlobOrders) {
            this.insertOrder(order, user, slot);
        }
        this.initialized = true;
        return true;
    }
    handleOrderRecord(record, slot) {
        this.insertOrder(record.order, record.user, slot);
    }
    handleOrderActionRecord(record, slot) {
        if ((0, __1.isOneOfVariant)(record.action, ['place', 'expire'])) {
            return;
        }
        if ((0, __1.isVariant)(record.action, 'trigger')) {
            if (record.taker !== null) {
                const takerOrder = this.getOrder(record.takerOrderId, record.taker);
                if (takerOrder) {
                    this.trigger(takerOrder, record.taker, slot);
                }
            }
            if (record.maker !== null) {
                const makerOrder = this.getOrder(record.makerOrderId, record.maker);
                if (makerOrder) {
                    this.trigger(makerOrder, record.maker, slot);
                }
            }
        }
        else if ((0, __1.isVariant)(record.action, 'fill')) {
            if (record.taker !== null) {
                const takerOrder = this.getOrder(record.takerOrderId, record.taker);
                if (takerOrder) {
                    this.updateOrder(takerOrder, record.taker, slot, record.takerOrderCumulativeBaseAssetAmountFilled);
                }
            }
            if (record.maker !== null) {
                const makerOrder = this.getOrder(record.makerOrderId, record.maker);
                if (makerOrder) {
                    this.updateOrder(makerOrder, record.maker, slot, record.makerOrderCumulativeBaseAssetAmountFilled);
                }
            }
        }
        else if ((0, __1.isVariant)(record.action, 'cancel')) {
            if (record.taker !== null) {
                const takerOrder = this.getOrder(record.takerOrderId, record.taker);
                if (takerOrder) {
                    this.delete(takerOrder, record.taker, slot);
                }
            }
            if (record.maker !== null) {
                const makerOrder = this.getOrder(record.makerOrderId, record.maker);
                if (makerOrder) {
                    this.delete(makerOrder, record.maker, slot);
                }
            }
        }
    }
    insertOrder(order, userAccount, slot, onInsert) {
        var _a;
        if ((0, __1.isVariant)(order.status, 'init')) {
            return;
        }
        if (!(0, __1.isOneOfVariant)(order.orderType, SUPPORTED_ORDER_TYPES)) {
            return;
        }
        const marketType = (0, __1.getVariant)(order.marketType);
        if (!this.orderLists.get(marketType).has(order.marketIndex)) {
            this.addOrderList(marketType, order.marketIndex);
        }
        if ((0, __1.isVariant)(order.status, 'open')) {
            this.openOrders
                .get(marketType)
                .add((0, NodeList_1.getOrderSignature)(order.orderId, userAccount));
        }
        (_a = this.getListForOrder(order, slot)) === null || _a === void 0 ? void 0 : _a.insert(order, marketType, userAccount);
        if (onInsert) {
            onInsert();
        }
    }
    addOrderList(marketType, marketIndex) {
        this.orderLists.get(marketType).set(marketIndex, {
            restingLimit: {
                ask: new NodeList_1.NodeList('restingLimit', 'asc'),
                bid: new NodeList_1.NodeList('restingLimit', 'desc'),
            },
            floatingLimit: {
                ask: new NodeList_1.NodeList('floatingLimit', 'asc'),
                bid: new NodeList_1.NodeList('floatingLimit', 'desc'),
            },
            takingLimit: {
                ask: new NodeList_1.NodeList('takingLimit', 'asc'),
                bid: new NodeList_1.NodeList('takingLimit', 'asc'), // always sort ascending for market orders
            },
            market: {
                ask: new NodeList_1.NodeList('market', 'asc'),
                bid: new NodeList_1.NodeList('market', 'asc'), // always sort ascending for market orders
            },
            trigger: {
                above: new NodeList_1.NodeList('trigger', 'asc'),
                below: new NodeList_1.NodeList('trigger', 'desc'),
            },
        });
    }
    updateOrder(order, userAccount, slot, cumulativeBaseAssetAmountFilled, onUpdate) {
        var _a;
        this.updateRestingLimitOrders(slot);
        if (order.baseAssetAmount.eq(cumulativeBaseAssetAmountFilled)) {
            this.delete(order, userAccount, slot);
            return;
        }
        if (order.baseAssetAmountFilled.eq(cumulativeBaseAssetAmountFilled)) {
            return;
        }
        const newOrder = {
            ...order,
        };
        newOrder.baseAssetAmountFilled = cumulativeBaseAssetAmountFilled;
        (_a = this.getListForOrder(order, slot)) === null || _a === void 0 ? void 0 : _a.update(newOrder, userAccount);
        if (onUpdate) {
            onUpdate();
        }
    }
    trigger(order, userAccount, slot, onTrigger) {
        var _a;
        if ((0, __1.isVariant)(order.status, 'init')) {
            return;
        }
        this.updateRestingLimitOrders(slot);
        if ((0, __1.isTriggered)(order)) {
            return;
        }
        const marketType = (0, __1.getVariant)(order.marketType);
        const triggerList = this.orderLists.get(marketType).get(order.marketIndex)
            .trigger[(0, __1.isVariant)(order.triggerCondition, 'above') ? 'above' : 'below'];
        triggerList.remove(order, userAccount);
        (_a = this.getListForOrder(order, slot)) === null || _a === void 0 ? void 0 : _a.insert(order, marketType, userAccount);
        if (onTrigger) {
            onTrigger();
        }
    }
    delete(order, userAccount, slot, onDelete) {
        var _a;
        if ((0, __1.isVariant)(order.status, 'init')) {
            return;
        }
        this.updateRestingLimitOrders(slot);
        (_a = this.getListForOrder(order, slot)) === null || _a === void 0 ? void 0 : _a.remove(order, userAccount);
        if (onDelete) {
            onDelete();
        }
    }
    getListForOrder(order, slot) {
        const isInactiveTriggerOrder = (0, __1.mustBeTriggered)(order) && !(0, __1.isTriggered)(order);
        let type;
        if (isInactiveTriggerOrder) {
            type = 'trigger';
        }
        else if ((0, __1.isOneOfVariant)(order.orderType, ['market', 'triggerMarket', 'oracle'])) {
            type = 'market';
        }
        else if (order.oraclePriceOffset !== 0) {
            type = 'floatingLimit';
        }
        else {
            const isResting = (0, __1.isRestingLimitOrder)(order, slot);
            type = isResting ? 'restingLimit' : 'takingLimit';
        }
        let subType;
        if (isInactiveTriggerOrder) {
            subType = (0, __1.isVariant)(order.triggerCondition, 'above') ? 'above' : 'below';
        }
        else {
            subType = (0, __1.isVariant)(order.direction, 'long') ? 'bid' : 'ask';
        }
        const marketType = (0, __1.getVariant)(order.marketType);
        if (!this.orderLists.has(marketType)) {
            return undefined;
        }
        return this.orderLists.get(marketType).get(order.marketIndex)[type][subType];
    }
    updateRestingLimitOrders(slot) {
        if (slot <= this.maxSlotForRestingLimitOrders) {
            return;
        }
        this.maxSlotForRestingLimitOrders = slot;
        this.updateRestingLimitOrdersForMarketType(slot, 'perp');
        this.updateRestingLimitOrdersForMarketType(slot, 'spot');
    }
    updateRestingLimitOrdersForMarketType(slot, marketTypeStr) {
        for (const [_, nodeLists] of this.orderLists.get(marketTypeStr)) {
            const nodesToUpdate = [];
            for (const node of nodeLists.takingLimit.ask.getGenerator()) {
                if (!(0, __1.isRestingLimitOrder)(node.order, slot)) {
                    continue;
                }
                nodesToUpdate.push({
                    side: 'ask',
                    node,
                });
            }
            for (const node of nodeLists.takingLimit.bid.getGenerator()) {
                if (!(0, __1.isRestingLimitOrder)(node.order, slot)) {
                    continue;
                }
                nodesToUpdate.push({
                    side: 'bid',
                    node,
                });
            }
            for (const nodeToUpdate of nodesToUpdate) {
                const { side, node } = nodeToUpdate;
                nodeLists.takingLimit[side].remove(node.order, node.userAccount);
                nodeLists.restingLimit[side].insert(node.order, marketTypeStr, node.userAccount);
            }
        }
    }
    getOrder(orderId, userAccount) {
        const orderSignature = (0, NodeList_1.getOrderSignature)(orderId, userAccount);
        for (const nodeList of this.getNodeLists()) {
            const node = nodeList.get(orderSignature);
            if (node) {
                return node.order;
            }
        }
        return undefined;
    }
    findNodesToFill(marketIndex, fallbackBid, fallbackAsk, slot, ts, marketType, oraclePriceData, stateAccount, marketAccount) {
        if ((0, exchangeStatus_1.fillPaused)(stateAccount, marketAccount)) {
            return [];
        }
        const isAmmPaused = (0, exchangeStatus_1.ammPaused)(stateAccount, marketAccount);
        const minAuctionDuration = (0, __1.isVariant)(marketType, 'perp')
            ? stateAccount.minPerpAuctionDuration
            : 0;
        const restingLimitOrderNodesToFill = this.findRestingLimitOrderNodesToFill(marketIndex, slot, marketType, oraclePriceData, isAmmPaused, minAuctionDuration, fallbackAsk, fallbackBid);
        const takingOrderNodesToFill = this.findTakingNodesToFill(marketIndex, slot, marketType, oraclePriceData, isAmmPaused, minAuctionDuration, fallbackAsk, fallbackBid);
        // get expired market nodes
        const expiredNodesToFill = this.findExpiredNodesToFill(marketIndex, ts, marketType);
        // for spot, multiple makers isn't supported, so don't merge
        if ((0, __1.isVariant)(marketType, 'spot')) {
            return restingLimitOrderNodesToFill.concat(takingOrderNodesToFill, expiredNodesToFill);
        }
        return this.mergeNodesToFill(restingLimitOrderNodesToFill, takingOrderNodesToFill).concat(expiredNodesToFill);
    }
    mergeNodesToFill(restingLimitOrderNodesToFill, takingOrderNodesToFill) {
        const mergedNodesToFill = new Map();
        const mergeNodesToFillHelper = (nodesToFillArray) => {
            nodesToFillArray.forEach((nodeToFill) => {
                const nodeSignature = (0, NodeList_1.getOrderSignature)(nodeToFill.node.order.orderId, nodeToFill.node.userAccount);
                if (!mergedNodesToFill.has(nodeSignature)) {
                    mergedNodesToFill.set(nodeSignature, {
                        node: nodeToFill.node,
                        makerNodes: [],
                    });
                }
                if (nodeToFill.makerNodes) {
                    mergedNodesToFill
                        .get(nodeSignature)
                        .makerNodes.push(...nodeToFill.makerNodes);
                }
            });
        };
        mergeNodesToFillHelper(restingLimitOrderNodesToFill);
        mergeNodesToFillHelper(takingOrderNodesToFill);
        return Array.from(mergedNodesToFill.values());
    }
    findRestingLimitOrderNodesToFill(marketIndex, slot, marketType, oraclePriceData, isAmmPaused, minAuctionDuration, fallbackAsk, fallbackBid) {
        const nodesToFill = new Array();
        const crossingNodes = this.findCrossingRestingLimitOrders(marketIndex, slot, marketType, oraclePriceData);
        for (const crossingNode of crossingNodes) {
            nodesToFill.push(crossingNode);
        }
        if (fallbackBid && !isAmmPaused) {
            const askGenerator = this.getRestingLimitAsks(marketIndex, slot, marketType, oraclePriceData);
            const asksCrossingFallback = this.findNodesCrossingFallbackLiquidity(marketType, slot, oraclePriceData, askGenerator, fallbackBid, (askPrice, fallbackPrice) => {
                return askPrice.lte(fallbackPrice);
            }, minAuctionDuration);
            for (const askCrossingFallback of asksCrossingFallback) {
                nodesToFill.push(askCrossingFallback);
            }
        }
        if (fallbackAsk && !isAmmPaused) {
            const bidGenerator = this.getRestingLimitBids(marketIndex, slot, marketType, oraclePriceData);
            const bidsCrossingFallback = this.findNodesCrossingFallbackLiquidity(marketType, slot, oraclePriceData, bidGenerator, fallbackAsk, (bidPrice, fallbackPrice) => {
                return bidPrice.gte(fallbackPrice);
            }, minAuctionDuration);
            for (const bidCrossingFallback of bidsCrossingFallback) {
                nodesToFill.push(bidCrossingFallback);
            }
        }
        return nodesToFill;
    }
    findTakingNodesToFill(marketIndex, slot, marketType, oraclePriceData, isAmmPaused, minAuctionDuration, fallbackAsk, fallbackBid) {
        const nodesToFill = new Array();
        let takingOrderGenerator = this.getTakingAsks(marketIndex, marketType, slot, oraclePriceData);
        const takingAsksCrossingBids = this.findTakingNodesCrossingMakerNodes(marketIndex, slot, marketType, oraclePriceData, takingOrderGenerator, this.getMakerLimitBids.bind(this), (takerPrice, makerPrice) => {
            if ((0, __1.isVariant)(marketType, 'spot')) {
                if (takerPrice === undefined) {
                    return false;
                }
                if (fallbackBid && makerPrice.lt(fallbackBid)) {
                    return false;
                }
            }
            return takerPrice === undefined || takerPrice.lte(makerPrice);
        }, fallbackAsk);
        for (const takingAskCrossingBid of takingAsksCrossingBids) {
            nodesToFill.push(takingAskCrossingBid);
        }
        if (fallbackBid && !isAmmPaused) {
            takingOrderGenerator = this.getTakingAsks(marketIndex, marketType, slot, oraclePriceData);
            const takingAsksCrossingFallback = this.findNodesCrossingFallbackLiquidity(marketType, slot, oraclePriceData, takingOrderGenerator, fallbackBid, (takerPrice, fallbackPrice) => {
                return takerPrice === undefined || takerPrice.lte(fallbackPrice);
            }, minAuctionDuration);
            for (const takingAskCrossingFallback of takingAsksCrossingFallback) {
                nodesToFill.push(takingAskCrossingFallback);
            }
        }
        takingOrderGenerator = this.getTakingBids(marketIndex, marketType, slot, oraclePriceData);
        const takingBidsToFill = this.findTakingNodesCrossingMakerNodes(marketIndex, slot, marketType, oraclePriceData, takingOrderGenerator, this.getMakerLimitAsks.bind(this), (takerPrice, makerPrice) => {
            if ((0, __1.isVariant)(marketType, 'spot')) {
                if (takerPrice === undefined) {
                    return false;
                }
                if (fallbackAsk && makerPrice.gt(fallbackAsk)) {
                    return false;
                }
            }
            return takerPrice === undefined || takerPrice.gte(makerPrice);
        }, fallbackBid);
        for (const takingBidToFill of takingBidsToFill) {
            nodesToFill.push(takingBidToFill);
        }
        if (fallbackAsk && !isAmmPaused) {
            takingOrderGenerator = this.getTakingBids(marketIndex, marketType, slot, oraclePriceData);
            const takingBidsCrossingFallback = this.findNodesCrossingFallbackLiquidity(marketType, slot, oraclePriceData, takingOrderGenerator, fallbackAsk, (takerPrice, fallbackPrice) => {
                return takerPrice === undefined || takerPrice.gte(fallbackPrice);
            }, minAuctionDuration);
            for (const marketBidCrossingFallback of takingBidsCrossingFallback) {
                nodesToFill.push(marketBidCrossingFallback);
            }
        }
        return nodesToFill;
    }
    findTakingNodesCrossingMakerNodes(marketIndex, slot, marketType, oraclePriceData, takerNodeGenerator, makerNodeGeneratorFn, doesCross, fallbackPrice) {
        const nodesToFill = new Array();
        for (const takerNode of takerNodeGenerator) {
            const makerNodeGenerator = makerNodeGeneratorFn(marketIndex, slot, marketType, oraclePriceData, fallbackPrice);
            for (const makerNode of makerNodeGenerator) {
                // Can't match orders from the same user
                const sameUser = takerNode.userAccount.equals(makerNode.userAccount);
                if (sameUser) {
                    continue;
                }
                const makerPrice = makerNode.getPrice(oraclePriceData, slot);
                const takerPrice = takerNode.getPrice(oraclePriceData, slot);
                const ordersCross = doesCross(takerPrice, makerPrice);
                if (!ordersCross) {
                    // market orders aren't sorted by price, they are sorted by time, so we need to traverse
                    // through all of em
                    break;
                }
                nodesToFill.push({
                    node: takerNode,
                    makerNodes: [makerNode],
                });
                const makerOrder = makerNode.order;
                const takerOrder = takerNode.order;
                const makerBaseRemaining = makerOrder.baseAssetAmount.sub(makerOrder.baseAssetAmountFilled);
                const takerBaseRemaining = takerOrder.baseAssetAmount.sub(takerOrder.baseAssetAmountFilled);
                const baseFilled = __1.BN.min(makerBaseRemaining, takerBaseRemaining);
                const newMakerOrder = { ...makerOrder };
                newMakerOrder.baseAssetAmountFilled =
                    makerOrder.baseAssetAmountFilled.add(baseFilled);
                this.getListForOrder(newMakerOrder, slot).update(newMakerOrder, makerNode.userAccount);
                const newTakerOrder = { ...takerOrder };
                newTakerOrder.baseAssetAmountFilled =
                    takerOrder.baseAssetAmountFilled.add(baseFilled);
                this.getListForOrder(newTakerOrder, slot).update(newTakerOrder, takerNode.userAccount);
                if (newTakerOrder.baseAssetAmountFilled.eq(takerOrder.baseAssetAmount)) {
                    break;
                }
            }
        }
        return nodesToFill;
    }
    findNodesCrossingFallbackLiquidity(marketType, slot, oraclePriceData, nodeGenerator, fallbackPrice, doesCross, minAuctionDuration) {
        var _a;
        const nodesToFill = new Array();
        let nextNode = nodeGenerator.next();
        while (!nextNode.done) {
            const node = nextNode.value;
            if ((0, __1.isVariant)(marketType, 'spot') && ((_a = node.order) === null || _a === void 0 ? void 0 : _a.postOnly)) {
                nextNode = nodeGenerator.next();
                continue;
            }
            const nodePrice = (0, __1.getLimitPrice)(node.order, oraclePriceData, slot);
            // order crosses if there is no limit price or it crosses fallback price
            const crosses = doesCross(nodePrice, fallbackPrice);
            // fallback is available if auction is complete or it's a spot order
            const fallbackAvailable = (0, __1.isVariant)(marketType, 'spot') ||
                (0, __1.isFallbackAvailableLiquiditySource)(node.order, minAuctionDuration, slot);
            if (crosses && fallbackAvailable) {
                nodesToFill.push({
                    node: node,
                    makerNodes: [], // filled by fallback
                });
            }
            nextNode = nodeGenerator.next();
        }
        return nodesToFill;
    }
    findExpiredNodesToFill(marketIndex, ts, marketType) {
        const nodesToFill = new Array();
        const marketTypeStr = (0, __1.getVariant)(marketType);
        const nodeLists = this.orderLists.get(marketTypeStr).get(marketIndex);
        if (!nodeLists) {
            return nodesToFill;
        }
        // All bids/asks that can expire
        const bidGenerators = [
            nodeLists.takingLimit.bid.getGenerator(),
            nodeLists.restingLimit.bid.getGenerator(),
            nodeLists.floatingLimit.bid.getGenerator(),
            nodeLists.market.bid.getGenerator(),
        ];
        const askGenerators = [
            nodeLists.takingLimit.ask.getGenerator(),
            nodeLists.restingLimit.ask.getGenerator(),
            nodeLists.floatingLimit.ask.getGenerator(),
            nodeLists.market.ask.getGenerator(),
        ];
        for (const bidGenerator of bidGenerators) {
            for (const bid of bidGenerator) {
                if ((0, __1.isOrderExpired)(bid.order, ts)) {
                    nodesToFill.push({
                        node: bid,
                        makerNodes: [],
                    });
                }
            }
        }
        for (const askGenerator of askGenerators) {
            for (const ask of askGenerator) {
                if ((0, __1.isOrderExpired)(ask.order, ts)) {
                    nodesToFill.push({
                        node: ask,
                        makerNodes: [],
                    });
                }
            }
        }
        return nodesToFill;
    }
    findJitAuctionNodesToFill(marketIndex, slot, oraclePriceData, marketType) {
        const nodesToFill = new Array();
        // Then see if there are orders still in JIT auction
        for (const marketBid of this.getTakingBids(marketIndex, marketType, slot, oraclePriceData)) {
            nodesToFill.push({
                node: marketBid,
                makerNodes: [],
            });
        }
        for (const marketAsk of this.getTakingAsks(marketIndex, marketType, slot, oraclePriceData)) {
            nodesToFill.push({
                node: marketAsk,
                makerNodes: [],
            });
        }
        return nodesToFill;
    }
    *getTakingBids(marketIndex, marketType, slot, oraclePriceData) {
        const marketTypeStr = (0, __1.getVariant)(marketType);
        const orderLists = this.orderLists.get(marketTypeStr).get(marketIndex);
        if (!orderLists) {
            return;
        }
        this.updateRestingLimitOrders(slot);
        const generatorList = [
            orderLists.market.bid.getGenerator(),
            orderLists.takingLimit.bid.getGenerator(),
        ];
        yield* this.getBestNode(generatorList, oraclePriceData, slot, (bestNode, currentNode) => {
            return bestNode.order.slot.lt(currentNode.order.slot);
        });
    }
    *getTakingAsks(marketIndex, marketType, slot, oraclePriceData) {
        const marketTypeStr = (0, __1.getVariant)(marketType);
        const orderLists = this.orderLists.get(marketTypeStr).get(marketIndex);
        if (!orderLists) {
            return;
        }
        this.updateRestingLimitOrders(slot);
        const generatorList = [
            orderLists.market.ask.getGenerator(),
            orderLists.takingLimit.ask.getGenerator(),
        ];
        yield* this.getBestNode(generatorList, oraclePriceData, slot, (bestNode, currentNode) => {
            return bestNode.order.slot.lt(currentNode.order.slot);
        });
    }
    *getBestNode(generatorList, oraclePriceData, slot, compareFcn) {
        const generators = generatorList.map((generator) => {
            return {
                next: generator.next(),
                generator,
            };
        });
        let sideExhausted = false;
        while (!sideExhausted) {
            const bestGenerator = generators.reduce((bestGenerator, currentGenerator) => {
                if (currentGenerator.next.done) {
                    return bestGenerator;
                }
                if (bestGenerator.next.done) {
                    return currentGenerator;
                }
                const bestValue = bestGenerator.next.value;
                const currentValue = currentGenerator.next.value;
                return compareFcn(bestValue, currentValue, slot, oraclePriceData)
                    ? bestGenerator
                    : currentGenerator;
            });
            if (!bestGenerator.next.done) {
                // skip this node if it's already completely filled
                if (bestGenerator.next.value.isBaseFilled()) {
                    bestGenerator.next = bestGenerator.generator.next();
                    continue;
                }
                yield bestGenerator.next.value;
                bestGenerator.next = bestGenerator.generator.next();
            }
            else {
                sideExhausted = true;
            }
        }
    }
    *getRestingLimitAsks(marketIndex, slot, marketType, oraclePriceData) {
        if ((0, __1.isVariant)(marketType, 'spot') && !oraclePriceData) {
            throw new Error('Must provide OraclePriceData to get spot asks');
        }
        this.updateRestingLimitOrders(slot);
        const marketTypeStr = (0, __1.getVariant)(marketType);
        const nodeLists = this.orderLists.get(marketTypeStr).get(marketIndex);
        if (!nodeLists) {
            return;
        }
        const generatorList = [
            nodeLists.restingLimit.ask.getGenerator(),
            nodeLists.floatingLimit.ask.getGenerator(),
        ];
        yield* this.getBestNode(generatorList, oraclePriceData, slot, (bestNode, currentNode, slot, oraclePriceData) => {
            return bestNode
                .getPrice(oraclePriceData, slot)
                .lt(currentNode.getPrice(oraclePriceData, slot));
        });
    }
    /**
     * Filters the limit asks that are resting and do not cross fallback bid
     * Taking orders can only fill against orders that meet this criteria
     *
     * @returns
     */
    *getMakerLimitAsks(marketIndex, slot, marketType, oraclePriceData, fallbackBid) {
        const isPerpMarket = (0, __1.isVariant)(marketType, 'perp');
        for (const node of this.getRestingLimitAsks(marketIndex, slot, marketType, oraclePriceData)) {
            if (isPerpMarket &&
                fallbackBid &&
                node.getPrice(oraclePriceData, slot).lte(fallbackBid)) {
                continue;
            }
            yield node;
        }
    }
    *getRestingLimitBids(marketIndex, slot, marketType, oraclePriceData) {
        if ((0, __1.isVariant)(marketType, 'spot') && !oraclePriceData) {
            throw new Error('Must provide OraclePriceData to get spot bids');
        }
        this.updateRestingLimitOrders(slot);
        const marketTypeStr = (0, __1.getVariant)(marketType);
        const nodeLists = this.orderLists.get(marketTypeStr).get(marketIndex);
        if (!nodeLists) {
            return;
        }
        const generatorList = [
            nodeLists.restingLimit.bid.getGenerator(),
            nodeLists.floatingLimit.bid.getGenerator(),
        ];
        yield* this.getBestNode(generatorList, oraclePriceData, slot, (bestNode, currentNode, slot, oraclePriceData) => {
            return bestNode
                .getPrice(oraclePriceData, slot)
                .gt(currentNode.getPrice(oraclePriceData, slot));
        });
    }
    /**
     * Filters the limit bids that are post only, have been place for sufficiently long or are below the fallback ask
     * Market orders can only fill against orders that meet this criteria
     *
     * @returns
     */
    *getMakerLimitBids(marketIndex, slot, marketType, oraclePriceData, fallbackAsk) {
        const isPerpMarket = (0, __1.isVariant)(marketType, 'perp');
        for (const node of this.getRestingLimitBids(marketIndex, slot, marketType, oraclePriceData)) {
            if (isPerpMarket &&
                fallbackAsk &&
                node.getPrice(oraclePriceData, slot).gte(fallbackAsk)) {
                continue;
            }
            yield node;
        }
    }
    *getAsks(marketIndex, fallbackAsk, slot, marketType, oraclePriceData) {
        if ((0, __1.isVariant)(marketType, 'spot') && !oraclePriceData) {
            throw new Error('Must provide OraclePriceData to get spot asks');
        }
        const generatorList = [
            this.getTakingAsks(marketIndex, marketType, slot, oraclePriceData),
            this.getRestingLimitAsks(marketIndex, slot, marketType, oraclePriceData),
        ];
        const marketTypeStr = (0, __1.getVariant)(marketType);
        if (marketTypeStr === 'perp' && fallbackAsk) {
            generatorList.push((0, NodeList_1.getVammNodeGenerator)(fallbackAsk));
        }
        yield* this.getBestNode(generatorList, oraclePriceData, slot, (bestNode, currentNode, slot, oraclePriceData) => {
            const bestNodeTaking = bestNode.order
                ? (0, __1.isTakingOrder)(bestNode.order, slot)
                : false;
            const currentNodeTaking = currentNode.order
                ? (0, __1.isTakingOrder)(currentNode.order, slot)
                : false;
            if (bestNodeTaking && currentNodeTaking) {
                return bestNode.order.slot.lt(currentNode.order.slot);
            }
            if (bestNodeTaking) {
                return true;
            }
            if (currentNodeTaking) {
                return false;
            }
            return bestNode
                .getPrice(oraclePriceData, slot)
                .lt(currentNode.getPrice(oraclePriceData, slot));
        });
    }
    *getBids(marketIndex, fallbackBid, slot, marketType, oraclePriceData) {
        if ((0, __1.isVariant)(marketType, 'spot') && !oraclePriceData) {
            throw new Error('Must provide OraclePriceData to get spot bids');
        }
        const generatorList = [
            this.getTakingBids(marketIndex, marketType, slot, oraclePriceData),
            this.getRestingLimitBids(marketIndex, slot, marketType, oraclePriceData),
        ];
        const marketTypeStr = (0, __1.getVariant)(marketType);
        if (marketTypeStr === 'perp' && fallbackBid) {
            generatorList.push((0, NodeList_1.getVammNodeGenerator)(fallbackBid));
        }
        yield* this.getBestNode(generatorList, oraclePriceData, slot, (bestNode, currentNode, slot, oraclePriceData) => {
            const bestNodeTaking = bestNode.order
                ? (0, __1.isTakingOrder)(bestNode.order, slot)
                : false;
            const currentNodeTaking = currentNode.order
                ? (0, __1.isTakingOrder)(currentNode.order, slot)
                : false;
            if (bestNodeTaking && currentNodeTaking) {
                return bestNode.order.slot.lt(currentNode.order.slot);
            }
            if (bestNodeTaking) {
                return true;
            }
            if (currentNodeTaking) {
                return false;
            }
            return bestNode
                .getPrice(oraclePriceData, slot)
                .gt(currentNode.getPrice(oraclePriceData, slot));
        });
    }
    findCrossingRestingLimitOrders(marketIndex, slot, marketType, oraclePriceData) {
        const nodesToFill = new Array();
        for (const askNode of this.getRestingLimitAsks(marketIndex, slot, marketType, oraclePriceData)) {
            const bidGenerator = this.getRestingLimitBids(marketIndex, slot, marketType, oraclePriceData);
            for (const bidNode of bidGenerator) {
                const bidPrice = bidNode.getPrice(oraclePriceData, slot);
                const askPrice = askNode.getPrice(oraclePriceData, slot);
                // orders don't cross
                if (bidPrice.lt(askPrice)) {
                    break;
                }
                const bidOrder = bidNode.order;
                const askOrder = askNode.order;
                // Can't match orders from the same user
                const sameUser = bidNode.userAccount.equals(askNode.userAccount);
                if (sameUser) {
                    continue;
                }
                const makerAndTaker = this.determineMakerAndTaker(askNode, bidNode);
                // unable to match maker and taker due to post only or slot
                if (!makerAndTaker) {
                    continue;
                }
                const { takerNode, makerNode } = makerAndTaker;
                const bidBaseRemaining = bidOrder.baseAssetAmount.sub(bidOrder.baseAssetAmountFilled);
                const askBaseRemaining = askOrder.baseAssetAmount.sub(askOrder.baseAssetAmountFilled);
                const baseFilled = __1.BN.min(bidBaseRemaining, askBaseRemaining);
                const newBidOrder = { ...bidOrder };
                newBidOrder.baseAssetAmountFilled =
                    bidOrder.baseAssetAmountFilled.add(baseFilled);
                this.getListForOrder(newBidOrder, slot).update(newBidOrder, bidNode.userAccount);
                // ask completely filled
                const newAskOrder = { ...askOrder };
                newAskOrder.baseAssetAmountFilled =
                    askOrder.baseAssetAmountFilled.add(baseFilled);
                this.getListForOrder(newAskOrder, slot).update(newAskOrder, askNode.userAccount);
                nodesToFill.push({
                    node: takerNode,
                    makerNodes: [makerNode],
                });
                if (newAskOrder.baseAssetAmount.eq(newAskOrder.baseAssetAmountFilled)) {
                    break;
                }
            }
        }
        return nodesToFill;
    }
    determineMakerAndTaker(askNode, bidNode) {
        const askSlot = askNode.order.slot.add(new __1.BN(askNode.order.auctionDuration));
        const bidSlot = bidNode.order.slot.add(new __1.BN(bidNode.order.auctionDuration));
        if (bidNode.order.postOnly && askNode.order.postOnly) {
            return undefined;
        }
        else if (bidNode.order.postOnly) {
            return {
                takerNode: askNode,
                makerNode: bidNode,
            };
        }
        else if (askNode.order.postOnly) {
            return {
                takerNode: bidNode,
                makerNode: askNode,
            };
        }
        else if (askSlot.lte(bidSlot)) {
            return {
                takerNode: bidNode,
                makerNode: askNode,
            };
        }
        else {
            return {
                takerNode: askNode,
                makerNode: bidNode,
            };
        }
    }
    getBestAsk(marketIndex, fallbackAsk, slot, marketType, oraclePriceData) {
        return this.getAsks(marketIndex, fallbackAsk, slot, marketType, oraclePriceData)
            .next()
            .value.getPrice(oraclePriceData, slot);
    }
    getBestBid(marketIndex, fallbackBid, slot, marketType, oraclePriceData) {
        return this.getBids(marketIndex, fallbackBid, slot, marketType, oraclePriceData)
            .next()
            .value.getPrice(oraclePriceData, slot);
    }
    findNodesToTrigger(marketIndex, slot, oraclePrice, marketType, stateAccount) {
        if ((0, exchangeStatus_1.exchangePaused)(stateAccount)) {
            return [];
        }
        const nodesToTrigger = [];
        const marketTypeStr = (0, __1.getVariant)(marketType);
        const marketNodeLists = this.orderLists.get(marketTypeStr).get(marketIndex);
        const triggerAboveList = marketNodeLists
            ? marketNodeLists.trigger.above
            : undefined;
        if (triggerAboveList) {
            for (const node of triggerAboveList.getGenerator()) {
                if (oraclePrice.gt(node.order.triggerPrice)) {
                    nodesToTrigger.push({
                        node: node,
                    });
                }
                else {
                    break;
                }
            }
        }
        const triggerBelowList = marketNodeLists
            ? marketNodeLists.trigger.below
            : undefined;
        if (triggerBelowList) {
            for (const node of triggerBelowList.getGenerator()) {
                if (oraclePrice.lt(node.order.triggerPrice)) {
                    nodesToTrigger.push({
                        node: node,
                    });
                }
                else {
                    break;
                }
            }
        }
        return nodesToTrigger;
    }
    printTopOfOrderLists(sdkConfig, driftClient, slotSubscriber, marketIndex, marketType) {
        if ((0, __1.isVariant)(marketType, 'perp')) {
            const market = driftClient.getPerpMarketAccount(marketIndex);
            const slot = slotSubscriber.getSlot();
            const oraclePriceData = driftClient.getOracleDataForPerpMarket(marketIndex);
            const fallbackAsk = (0, __1.calculateAskPrice)(market, oraclePriceData);
            const fallbackBid = (0, __1.calculateBidPrice)(market, oraclePriceData);
            const bestAsk = this.getBestAsk(marketIndex, fallbackAsk, slot, marketType, oraclePriceData);
            const bestBid = this.getBestBid(marketIndex, fallbackBid, slot, marketType, oraclePriceData);
            const mid = bestAsk.add(bestBid).div(new __1.BN(2));
            const bidSpread = ((0, __1.convertToNumber)(bestBid, __1.PRICE_PRECISION) /
                (0, __1.convertToNumber)(oraclePriceData.price, __1.PRICE_PRECISION) -
                1) *
                100.0;
            const askSpread = ((0, __1.convertToNumber)(bestAsk, __1.PRICE_PRECISION) /
                (0, __1.convertToNumber)(oraclePriceData.price, __1.PRICE_PRECISION) -
                1) *
                100.0;
            console.log(`Market ${sdkConfig.MARKETS[marketIndex].symbol} Orders`);
            console.log(`  Ask`, (0, __1.convertToNumber)(bestAsk, __1.PRICE_PRECISION).toFixed(3), `(${askSpread.toFixed(4)}%)`);
            console.log(`  Mid`, (0, __1.convertToNumber)(mid, __1.PRICE_PRECISION).toFixed(3));
            console.log(`  Bid`, (0, __1.convertToNumber)(bestBid, __1.PRICE_PRECISION).toFixed(3), `(${bidSpread.toFixed(4)}%)`);
        }
        else if ((0, __1.isVariant)(marketType, 'spot')) {
            const slot = slotSubscriber.getSlot();
            const oraclePriceData = driftClient.getOracleDataForPerpMarket(marketIndex);
            const bestAsk = this.getBestAsk(marketIndex, undefined, slot, marketType, oraclePriceData);
            const bestBid = this.getBestBid(marketIndex, undefined, slot, marketType, oraclePriceData);
            const mid = bestAsk.add(bestBid).div(new __1.BN(2));
            const bidSpread = ((0, __1.convertToNumber)(bestBid, __1.PRICE_PRECISION) /
                (0, __1.convertToNumber)(oraclePriceData.price, __1.PRICE_PRECISION) -
                1) *
                100.0;
            const askSpread = ((0, __1.convertToNumber)(bestAsk, __1.PRICE_PRECISION) /
                (0, __1.convertToNumber)(oraclePriceData.price, __1.PRICE_PRECISION) -
                1) *
                100.0;
            console.log(`Market ${sdkConfig.MARKETS[marketIndex].symbol} Orders`);
            console.log(`  Ask`, (0, __1.convertToNumber)(bestAsk, __1.PRICE_PRECISION).toFixed(3), `(${askSpread.toFixed(4)}%)`);
            console.log(`  Mid`, (0, __1.convertToNumber)(mid, __1.PRICE_PRECISION).toFixed(3));
            console.log(`  Bid`, (0, __1.convertToNumber)(bestBid, __1.PRICE_PRECISION).toFixed(3), `(${bidSpread.toFixed(4)}%)`);
        }
    }
    getDLOBOrders() {
        const dlobOrders = [];
        for (const nodeList of this.getNodeLists()) {
            for (const node of nodeList.getGenerator()) {
                dlobOrders.push({
                    user: node.userAccount,
                    order: node.order,
                });
            }
        }
        return dlobOrders;
    }
    *getNodeLists() {
        for (const [_, nodeLists] of this.orderLists.get('perp')) {
            yield nodeLists.restingLimit.bid;
            yield nodeLists.restingLimit.ask;
            yield nodeLists.takingLimit.bid;
            yield nodeLists.takingLimit.ask;
            yield nodeLists.market.bid;
            yield nodeLists.market.ask;
            yield nodeLists.floatingLimit.bid;
            yield nodeLists.floatingLimit.ask;
            yield nodeLists.trigger.above;
            yield nodeLists.trigger.below;
        }
        for (const [_, nodeLists] of this.orderLists.get('spot')) {
            yield nodeLists.restingLimit.bid;
            yield nodeLists.restingLimit.ask;
            yield nodeLists.takingLimit.bid;
            yield nodeLists.takingLimit.ask;
            yield nodeLists.market.bid;
            yield nodeLists.market.ask;
            yield nodeLists.floatingLimit.bid;
            yield nodeLists.floatingLimit.ask;
            yield nodeLists.trigger.above;
            yield nodeLists.trigger.below;
        }
    }
    /**
     * Get an L2 view of the order book for a given market.
     *
     * @param marketIndex
     * @param marketType
     * @param slot
     * @param oraclePriceData
     * @param depth how many levels of the order book to return
     * @param fallbackAsk best ask for fallback liquidity, only relevant for perps
     * @param fallbackBid best bid for fallback liquidity, only relevant for perps
     * @param fallbackL2Generators L2 generators for fallback liquidity e.g. vAMM {@link getVammL2Generator}, openbook {@link SerumSubscriber}
     */
    getL2({ marketIndex, marketType, slot, oraclePriceData, depth, fallbackAsk, fallbackBid, fallbackL2Generators = [], }) {
        const makerAskL2LevelGenerator = (0, orderBookLevels_1.getL2GeneratorFromDLOBNodes)(this.getMakerLimitAsks(marketIndex, slot, marketType, oraclePriceData, fallbackBid), oraclePriceData, slot);
        const fallbackAskGenerators = fallbackL2Generators.map((fallbackL2Generator) => {
            return fallbackL2Generator.getL2Asks();
        });
        const askL2LevelGenerator = (0, orderBookLevels_1.mergeL2LevelGenerators)([makerAskL2LevelGenerator, ...fallbackAskGenerators], (a, b) => {
            return a.price.lt(b.price);
        });
        const asks = (0, orderBookLevels_1.createL2Levels)(askL2LevelGenerator, depth);
        const makerBidGenerator = (0, orderBookLevels_1.getL2GeneratorFromDLOBNodes)(this.getMakerLimitBids(marketIndex, slot, marketType, oraclePriceData, fallbackAsk), oraclePriceData, slot);
        const fallbackBidGenerators = fallbackL2Generators.map((fallbackOrders) => {
            return fallbackOrders.getL2Bids();
        });
        const bidL2LevelGenerator = (0, orderBookLevels_1.mergeL2LevelGenerators)([makerBidGenerator, ...fallbackBidGenerators], (a, b) => {
            return a.price.gt(b.price);
        });
        const bids = (0, orderBookLevels_1.createL2Levels)(bidL2LevelGenerator, depth);
        return {
            bids,
            asks,
        };
    }
    /**
     * Get an L3 view of the order book for a given market. Does not include fallback liquidity sources
     *
     * @param marketIndex
     * @param marketType
     * @param slot
     * @param oraclePriceData
     */
    getL3({ marketIndex, marketType, slot, oraclePriceData, }) {
        const bids = [];
        const asks = [];
        const restingAsks = this.getRestingLimitAsks(marketIndex, slot, marketType, oraclePriceData);
        for (const ask of restingAsks) {
            asks.push({
                price: ask.getPrice(oraclePriceData, slot),
                size: ask.order.baseAssetAmount.sub(ask.order.baseAssetAmountFilled),
                maker: ask.userAccount,
                orderId: ask.order.orderId,
            });
        }
        const restingBids = this.getRestingLimitBids(marketIndex, slot, marketType, oraclePriceData);
        for (const bid of restingBids) {
            bids.push({
                price: bid.getPrice(oraclePriceData, slot),
                size: bid.order.baseAssetAmount.sub(bid.order.baseAssetAmountFilled),
                maker: bid.userAccount,
                orderId: bid.order.orderId,
            });
        }
        return {
            bids,
            asks,
        };
    }
}
exports.DLOB = DLOB;
