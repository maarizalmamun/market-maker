"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVammL2Generator = exports.createL2Levels = exports.mergeL2LevelGenerators = exports.getL2GeneratorFromDLOBNodes = void 0;
const __1 = require("..");
/**
 * Get an {@link Generator<L2Level>} generator from a {@link Generator<DLOBNode>}
 * @param dlobNodes e.g. {@link DLOB#getMakerLimitAsks} or {@link DLOB#getMakerLimitBids}
 * @param oraclePriceData
 * @param slot
 */
function* getL2GeneratorFromDLOBNodes(dlobNodes, oraclePriceData, slot) {
    for (const dlobNode of dlobNodes) {
        const size = dlobNode.order.baseAssetAmount.sub(dlobNode.order.baseAssetAmountFilled);
        yield {
            size,
            price: dlobNode.getPrice(oraclePriceData, slot),
            sources: {
                dlob: size,
            },
        };
    }
}
exports.getL2GeneratorFromDLOBNodes = getL2GeneratorFromDLOBNodes;
function* mergeL2LevelGenerators(l2LevelGenerators, compare) {
    const generators = l2LevelGenerators.map((generator) => {
        return {
            generator,
            next: generator.next(),
        };
    });
    let next;
    do {
        next = generators.reduce((best, next) => {
            if (next.next.done) {
                return best;
            }
            if (!best) {
                return next;
            }
            if (compare(next.next.value, best.next.value)) {
                return next;
            }
            else {
                return best;
            }
        }, undefined);
        if (next) {
            yield next.next.value;
            next.next = next.generator.next();
        }
    } while (next !== undefined);
}
exports.mergeL2LevelGenerators = mergeL2LevelGenerators;
function createL2Levels(generator, depth) {
    const levels = [];
    for (const level of generator) {
        const price = level.price;
        const size = level.size;
        if (levels.length > 0 && levels[levels.length - 1].price.eq(price)) {
            const currentLevel = levels[levels.length - 1];
            currentLevel.size.add(size);
            for (const [source, size] of Object.entries(level.sources)) {
                if (currentLevel.sources[source]) {
                    currentLevel.sources[source] = currentLevel.sources[source].add(size);
                }
                else {
                    currentLevel.sources[source] = size;
                }
            }
        }
        else if (levels.length === depth) {
            break;
        }
        else {
            levels.push(level);
        }
    }
    return levels;
}
exports.createL2Levels = createL2Levels;
function getVammL2Generator({ marketAccount, oraclePriceData, numOrders, now, }) {
    const updatedAmm = (0, __1.calculateUpdatedAMM)(marketAccount.amm, oraclePriceData);
    const [openBids, openAsks] = (0, __1.calculateMarketOpenBidAsk)(updatedAmm.baseAssetReserve, updatedAmm.minBaseAssetReserve, updatedAmm.maxBaseAssetReserve, updatedAmm.orderStepSize);
    now = now !== null && now !== void 0 ? now : new __1.BN(Date.now() / 1000);
    const [bidReserves, askReserves] = (0, __1.calculateSpreadReserves)(updatedAmm, oraclePriceData, now);
    let numBids = 0;
    const baseSize = openBids.div(new __1.BN(numOrders));
    const bidAmm = {
        baseAssetReserve: bidReserves.baseAssetReserve,
        quoteAssetReserve: bidReserves.quoteAssetReserve,
        sqrtK: updatedAmm.sqrtK,
        pegMultiplier: updatedAmm.pegMultiplier,
    };
    const getL2Bids = function* () {
        while (numBids < numOrders) {
            const [afterSwapQuoteReserves, afterSwapBaseReserves] = (0, __1.calculateAmmReservesAfterSwap)(bidAmm, 'base', baseSize, __1.SwapDirection.ADD);
            const quoteSwapped = (0, __1.calculateQuoteAssetAmountSwapped)(bidAmm.quoteAssetReserve.sub(afterSwapQuoteReserves).abs(), bidAmm.pegMultiplier, __1.SwapDirection.ADD);
            const price = quoteSwapped.mul(__1.BASE_PRECISION).div(baseSize);
            bidAmm.baseAssetReserve = afterSwapBaseReserves;
            bidAmm.quoteAssetReserve = afterSwapQuoteReserves;
            yield {
                price,
                size: baseSize,
                sources: { vamm: baseSize },
            };
            numBids++;
        }
    };
    let numAsks = 0;
    const askSize = openAsks.abs().div(new __1.BN(numOrders));
    const askAmm = {
        baseAssetReserve: askReserves.baseAssetReserve,
        quoteAssetReserve: askReserves.quoteAssetReserve,
        sqrtK: updatedAmm.sqrtK,
        pegMultiplier: updatedAmm.pegMultiplier,
    };
    const getL2Asks = function* () {
        while (numAsks < numOrders) {
            const [afterSwapQuoteReserves, afterSwapBaseReserves] = (0, __1.calculateAmmReservesAfterSwap)(askAmm, 'base', askSize, __1.SwapDirection.REMOVE);
            const quoteSwapped = (0, __1.calculateQuoteAssetAmountSwapped)(askAmm.quoteAssetReserve.sub(afterSwapQuoteReserves).abs(), askAmm.pegMultiplier, __1.SwapDirection.REMOVE);
            const price = quoteSwapped.mul(__1.BASE_PRECISION).div(askSize);
            askAmm.baseAssetReserve = afterSwapBaseReserves;
            askAmm.quoteAssetReserve = afterSwapQuoteReserves;
            yield {
                price,
                size: askSize,
                sources: { vamm: baseSize },
            };
            numAsks++;
        }
    };
    return {
        getL2Bids,
        getL2Asks,
    };
}
exports.getVammL2Generator = getVammL2Generator;
