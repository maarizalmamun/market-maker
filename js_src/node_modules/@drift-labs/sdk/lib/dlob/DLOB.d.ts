import { NodeList } from '@drift-labs/sdk/lib/dlob/NodeList';
import { BN, DLOBNode, DLOBNodeType, DriftClient, MarketType, MarketTypeStr, OraclePriceData, Order, OrderActionRecord, OrderRecord, PerpMarketAccount, SlotSubscriber, SpotMarketAccount, StateAccount, TriggerOrderNode, UserMap } from '@drift-labs/sdk';
import { PublicKey } from '@solana/web3.js';
import { DLOBOrders } from '@drift-labs/sdk/lib/dlob/DLOBOrders';
import { L2OrderBook, L2OrderBookGenerator, L3OrderBook } from '@drift-labs/sdk/lib/dlob/orderBookLevels';
export type MarketNodeLists = {
    restingLimit: {
        ask: NodeList<'restingLimit'>;
        bid: NodeList<'restingLimit'>;
    };
    floatingLimit: {
        ask: NodeList<'floatingLimit'>;
        bid: NodeList<'floatingLimit'>;
    };
    takingLimit: {
        ask: NodeList<'takingLimit'>;
        bid: NodeList<'takingLimit'>;
    };
    market: {
        ask: NodeList<'market'>;
        bid: NodeList<'market'>;
    };
    trigger: {
        above: NodeList<'trigger'>;
        below: NodeList<'trigger'>;
    };
};
type OrderBookCallback = () => void;
export type NodeToFill = {
    node: DLOBNode;
    makerNodes: DLOBNode[];
};
export type NodeToTrigger = {
    node: TriggerOrderNode;
};
export declare class DLOB {
    openOrders: Map<MarketTypeStr, Set<string>>;
    orderLists: Map<MarketTypeStr, Map<number, MarketNodeLists>>;
    maxSlotForRestingLimitOrders: number;
    initialized: boolean;
    constructor();
    private init;
    clear(): void;
    /**
     * initializes a new DLOB instance
     *
     * @returns a promise that resolves when the DLOB is initialized
     */
    initFromUserMap(userMap: UserMap, slot: number): Promise<boolean>;
    initFromOrders(dlobOrders: DLOBOrders, slot: number): boolean;
    handleOrderRecord(record: OrderRecord, slot: number): void;
    handleOrderActionRecord(record: OrderActionRecord, slot: number): void;
    insertOrder(order: Order, userAccount: PublicKey, slot: number, onInsert?: OrderBookCallback): void;
    addOrderList(marketType: MarketTypeStr, marketIndex: number): void;
    updateOrder(order: Order, userAccount: PublicKey, slot: number, cumulativeBaseAssetAmountFilled: BN, onUpdate?: OrderBookCallback): void;
    trigger(order: Order, userAccount: PublicKey, slot: number, onTrigger?: OrderBookCallback): void;
    delete(order: Order, userAccount: PublicKey, slot: number, onDelete?: OrderBookCallback): void;
    getListForOrder(order: Order, slot: number): NodeList<any> | undefined;
    updateRestingLimitOrders(slot: number): void;
    updateRestingLimitOrdersForMarketType(slot: number, marketTypeStr: MarketTypeStr): void;
    getOrder(orderId: number, userAccount: PublicKey): Order | undefined;
    findNodesToFill(marketIndex: number, fallbackBid: BN | undefined, fallbackAsk: BN | undefined, slot: number, ts: number, marketType: MarketType, oraclePriceData: OraclePriceData, stateAccount: StateAccount, marketAccount: PerpMarketAccount | SpotMarketAccount): NodeToFill[];
    mergeNodesToFill(restingLimitOrderNodesToFill: NodeToFill[], takingOrderNodesToFill: NodeToFill[]): NodeToFill[];
    findRestingLimitOrderNodesToFill(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData, isAmmPaused: boolean, minAuctionDuration: number, fallbackAsk: BN | undefined, fallbackBid: BN | undefined): NodeToFill[];
    findTakingNodesToFill(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData, isAmmPaused: boolean, minAuctionDuration: number, fallbackAsk: BN | undefined, fallbackBid?: BN | undefined): NodeToFill[];
    findTakingNodesCrossingMakerNodes(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData, takerNodeGenerator: Generator<DLOBNode>, makerNodeGeneratorFn: (marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData, fallbackPrice?: BN) => Generator<DLOBNode>, doesCross: (takerPrice: BN | undefined, makerPrice: BN) => boolean, fallbackPrice?: BN): NodeToFill[];
    findNodesCrossingFallbackLiquidity(marketType: MarketType, slot: number, oraclePriceData: OraclePriceData, nodeGenerator: Generator<DLOBNode>, fallbackPrice: BN, doesCross: (nodePrice: BN | undefined, fallbackPrice: BN) => boolean, minAuctionDuration: number): NodeToFill[];
    findExpiredNodesToFill(marketIndex: number, ts: number, marketType: MarketType): NodeToFill[];
    findJitAuctionNodesToFill(marketIndex: number, slot: number, oraclePriceData: OraclePriceData, marketType: MarketType): NodeToFill[];
    getTakingBids(marketIndex: number, marketType: MarketType, slot: number, oraclePriceData: OraclePriceData): Generator<DLOBNode>;
    getTakingAsks(marketIndex: number, marketType: MarketType, slot: number, oraclePriceData: OraclePriceData): Generator<DLOBNode>;
    private getBestNode;
    getRestingLimitAsks(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData): Generator<DLOBNode>;
    /**
     * Filters the limit asks that are resting and do not cross fallback bid
     * Taking orders can only fill against orders that meet this criteria
     *
     * @returns
     */
    getMakerLimitAsks(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData, fallbackBid?: BN): Generator<DLOBNode>;
    getRestingLimitBids(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData): Generator<DLOBNode>;
    /**
     * Filters the limit bids that are post only, have been place for sufficiently long or are below the fallback ask
     * Market orders can only fill against orders that meet this criteria
     *
     * @returns
     */
    getMakerLimitBids(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData, fallbackAsk?: BN): Generator<DLOBNode>;
    getAsks(marketIndex: number, fallbackAsk: BN | undefined, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData): Generator<DLOBNode>;
    getBids(marketIndex: number, fallbackBid: BN | undefined, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData): Generator<DLOBNode>;
    findCrossingRestingLimitOrders(marketIndex: number, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData): NodeToFill[];
    determineMakerAndTaker(askNode: DLOBNode, bidNode: DLOBNode): {
        takerNode: DLOBNode;
        makerNode: DLOBNode;
    } | undefined;
    getBestAsk(marketIndex: number, fallbackAsk: BN | undefined, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData): BN;
    getBestBid(marketIndex: number, fallbackBid: BN | undefined, slot: number, marketType: MarketType, oraclePriceData: OraclePriceData): BN;
    findNodesToTrigger(marketIndex: number, slot: number, oraclePrice: BN, marketType: MarketType, stateAccount: StateAccount): NodeToTrigger[];
    printTopOfOrderLists(sdkConfig: any, driftClient: DriftClient, slotSubscriber: SlotSubscriber, marketIndex: number, marketType: MarketType): void;
    getDLOBOrders(): DLOBOrders;
    getNodeLists(): Generator<NodeList<DLOBNodeType>>;
    /**
     * Get an L2 view of the order book for a given market.
     *
     * @param marketIndex
     * @param marketType
     * @param slot
     * @param oraclePriceData
     * @param depth how many levels of the order book to return
     * @param fallbackAsk best ask for fallback liquidity, only relevant for perps
     * @param fallbackBid best bid for fallback liquidity, only relevant for perps
     * @param fallbackL2Generators L2 generators for fallback liquidity e.g. vAMM {@link getVammL2Generator}, openbook {@link SerumSubscriber}
     */
    getL2({ marketIndex, marketType, slot, oraclePriceData, depth, fallbackAsk, fallbackBid, fallbackL2Generators, }: {
        marketIndex: number;
        marketType: MarketType;
        slot: number;
        oraclePriceData: OraclePriceData;
        depth: number;
        fallbackAsk?: BN;
        fallbackBid?: BN;
        fallbackL2Generators?: L2OrderBookGenerator[];
    }): L2OrderBook;
    /**
     * Get an L3 view of the order book for a given market. Does not include fallback liquidity sources
     *
     * @param marketIndex
     * @param marketType
     * @param slot
     * @param oraclePriceData
     */
    getL3({ marketIndex, marketType, slot, oraclePriceData, }: {
        marketIndex: number;
        marketType: MarketType;
        slot: number;
        oraclePriceData: OraclePriceData;
    }): L3OrderBook;
}
export {};
