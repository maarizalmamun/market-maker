"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryTxSender = void 0;
const web3_js_1 = require("@solana/web3.js");
const assert_1 = __importDefault(require("assert"));
const bs58_1 = __importDefault(require("bs58"));
const DEFAULT_TIMEOUT = 35000;
const DEFAULT_RETRY = 8000;
class RetryTxSender {
    constructor(provider, timeout, retrySleep, additionalConnections = new Array()) {
        this.provider = provider;
        this.timeout = timeout !== null && timeout !== void 0 ? timeout : DEFAULT_TIMEOUT;
        this.retrySleep = retrySleep !== null && retrySleep !== void 0 ? retrySleep : DEFAULT_RETRY;
        this.additionalConnections = additionalConnections;
    }
    async send(tx, additionalSigners, opts, preSigned) {
        if (additionalSigners === undefined) {
            additionalSigners = [];
        }
        if (opts === undefined) {
            opts = this.provider.opts;
        }
        const signedTx = preSigned
            ? tx
            : await this.prepareTx(tx, additionalSigners, opts);
        return this.sendRawTransaction(signedTx.serialize(), opts);
    }
    async prepareTx(tx, additionalSigners, opts) {
        tx.feePayer = this.provider.wallet.publicKey;
        tx.recentBlockhash = (await this.provider.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;
        additionalSigners
            .filter((s) => s !== undefined)
            .forEach((kp) => {
            tx.partialSign(kp);
        });
        const signedTx = await this.provider.wallet.signTransaction(tx);
        return signedTx;
    }
    async getVersionedTransaction(ixs, lookupTableAccounts, additionalSigners, opts) {
        if (additionalSigners === undefined) {
            additionalSigners = [];
        }
        if (opts === undefined) {
            opts = this.provider.opts;
        }
        const message = new web3_js_1.TransactionMessage({
            payerKey: this.provider.wallet.publicKey,
            recentBlockhash: (await this.provider.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash,
            instructions: ixs,
        }).compileToV0Message(lookupTableAccounts);
        const tx = new web3_js_1.VersionedTransaction(message);
        return tx;
    }
    async sendVersionedTransaction(ixs, lookupTableAccounts, additionalSigners, opts) {
        const tx = await this.getVersionedTransaction(ixs, lookupTableAccounts, additionalSigners, opts);
        // @ts-ignore
        tx.sign(additionalSigners.concat(this.provider.wallet.payer));
        return this.sendRawTransaction(tx.serialize(), opts);
    }
    async sendRawTransaction(rawTransaction, opts) {
        const startTime = this.getTimestamp();
        let txid;
        try {
            txid = await this.provider.connection.sendRawTransaction(rawTransaction, opts);
            this.sendToAdditionalConnections(rawTransaction, opts);
        }
        catch (e) {
            console.error(e);
            throw e;
        }
        let done = false;
        const resolveReference = {
            resolve: undefined,
        };
        const stopWaiting = () => {
            done = true;
            if (resolveReference.resolve) {
                resolveReference.resolve();
            }
        };
        (async () => {
            while (!done && this.getTimestamp() - startTime < this.timeout) {
                await this.sleep(resolveReference);
                if (!done) {
                    this.provider.connection
                        .sendRawTransaction(rawTransaction, opts)
                        .catch((e) => {
                        console.error(e);
                        stopWaiting();
                    });
                    this.sendToAdditionalConnections(rawTransaction, opts);
                }
            }
        })();
        let slot;
        try {
            const result = await this.confirmTransaction(txid, opts.commitment);
            slot = result.context.slot;
        }
        catch (e) {
            console.error(e);
            throw e;
        }
        finally {
            stopWaiting();
        }
        return { txSig: txid, slot };
    }
    async confirmTransaction(signature, commitment) {
        let decodedSignature;
        try {
            decodedSignature = bs58_1.default.decode(signature);
        }
        catch (err) {
            throw new Error('signature must be base58 encoded: ' + signature);
        }
        (0, assert_1.default)(decodedSignature.length === 64, 'signature has invalid length');
        const start = Date.now();
        const subscriptionCommitment = commitment || this.provider.opts.commitment;
        const subscriptionIds = new Array();
        const connections = [
            this.provider.connection,
            ...this.additionalConnections,
        ];
        let response = null;
        const promises = connections.map((connection, i) => {
            let subscriptionId;
            const confirmPromise = new Promise((resolve, reject) => {
                try {
                    subscriptionId = connection.onSignature(signature, (result, context) => {
                        subscriptionIds[i] = undefined;
                        response = {
                            context,
                            value: result,
                        };
                        resolve(null);
                    }, subscriptionCommitment);
                }
                catch (err) {
                    reject(err);
                }
            });
            subscriptionIds.push(subscriptionId);
            return confirmPromise;
        });
        try {
            await this.promiseTimeout(promises, this.timeout);
        }
        finally {
            for (const [i, subscriptionId] of subscriptionIds.entries()) {
                if (subscriptionId) {
                    connections[i].removeSignatureListener(subscriptionId);
                }
            }
        }
        if (response === null) {
            const duration = (Date.now() - start) / 1000;
            throw new Error(`Transaction was not confirmed in ${duration.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`);
        }
        return response;
    }
    getTimestamp() {
        return new Date().getTime();
    }
    async sleep(reference) {
        return new Promise((resolve) => {
            reference.resolve = resolve;
            setTimeout(resolve, this.retrySleep);
        });
    }
    promiseTimeout(promises, timeoutMs) {
        let timeoutId;
        const timeoutPromise = new Promise((resolve) => {
            timeoutId = setTimeout(() => resolve(null), timeoutMs);
        });
        return Promise.race([...promises, timeoutPromise]).then((result) => {
            clearTimeout(timeoutId);
            return result;
        });
    }
    sendToAdditionalConnections(rawTx, opts) {
        this.additionalConnections.map((connection) => {
            connection.sendRawTransaction(rawTx, opts).catch((e) => {
                console.error(
                // @ts-ignore
                `error sending tx to additional connection ${connection._rpcEndpoint}`);
                console.error(e);
            });
        });
    }
    addAdditionalConnection(newConnection) {
        const alreadyUsingConnection = this.additionalConnections.filter((connection) => {
            // @ts-ignore
            return connection._rpcEndpoint === newConnection.rpcEndpoint;
        }).length > 0;
        if (!alreadyUsingConnection) {
            this.additionalConnections.push(newConnection);
        }
    }
}
exports.RetryTxSender = RetryTxSender;
